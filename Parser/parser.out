Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    ELSEIF
    FALSE
    LIST
    TRUE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> empty
Rule 2     prog -> func prog
Rule 3     func -> func1
Rule 4     func -> func2
Rule 5     empty -> <empty>
Rule 6     stmt -> expr SEMI_COLON
Rule 7     stmt -> defvar SEMI_COLON
Rule 8     stmt -> func SEMI_COLON
Rule 9     stmt -> single_if
Rule 10    stmt -> else_if
Rule 11    stmt -> while_loop
Rule 12    stmt -> for_loop
Rule 13    stmt -> do_while
Rule 14    stmt -> return_is SEMI_COLON
Rule 15    stmt -> block
Rule 16    body -> empty
Rule 17    body -> stmt body
Rule 18    return_is -> RETURN expr
Rule 19    while_loop -> WHILE LPAREN expr RPAREN stmt
Rule 20    for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt
Rule 21    do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
Rule 22    block -> BEGIN body END
Rule 23    single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
Rule 24    else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
Rule 25    defvar -> ID DBL_COLON type
Rule 26    defvar -> ID DBL_COLON type EQ expr
Rule 27    type -> INT
Rule 28    type -> STRING
Rule 29    type -> VECTOR
Rule 30    type -> NULL
Rule 31    type -> BOOLEAN
Rule 32    func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
Rule 33    func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
Rule 34    flist -> empty
Rule 35    flist -> ID AS type
Rule 36    flist -> ID AS type COMMA flist
Rule 37    clist -> empty
Rule 38    clist -> expr
Rule 39    clist -> expr COMMA clist
Rule 40    expr -> on_list
Rule 41    expr -> expr_list
Rule 42    expr -> ternary_expr
Rule 43    expr -> binary_expr
Rule 44    expr -> ID
Rule 45    expr -> assignment
Rule 46    expr -> function_call
Rule 47    expr -> NUMBER
Rule 48    expr -> STRING
Rule 49    assignment -> ID EQ expr
Rule 50    on_list -> expr LSQUAREBR expr RSQUAREBR
Rule 51    expr_list -> LSQUAREBR clist RSQUAREBR
Rule 52    ternary_expr -> expr QUESTION_MARK expr COLON expr
Rule 53    function_call -> ID LPAREN clist RPAREN
Rule 54    binary_expr -> expr PLUS expr
Rule 55    binary_expr -> expr MINUS expr
Rule 56    binary_expr -> expr TIMES expr
Rule 57    binary_expr -> expr DIVIDE expr
Rule 58    binary_expr -> expr GREATER_THAN expr
Rule 59    binary_expr -> expr LESS_THAN expr
Rule 60    binary_expr -> expr DOUBLE_EQ expr
Rule 61    binary_expr -> expr GREATER_THAN_EQ expr
Rule 62    binary_expr -> expr LESS_THAN_EQ expr
Rule 63    binary_expr -> expr NOT_EQ expr
Rule 64    binary_expr -> expr AND expr
Rule 65    binary_expr -> expr OR expr
Rule 66    binary_expr -> NOT expr
Rule 67    binary_expr -> PLUS expr
Rule 68    binary_expr -> MINUS expr
Rule 69    builtin_methods -> SCAN LPAREN RPAREN
Rule 70    builtin_methods -> PRINT LPAREN clist RPAREN
Rule 71    builtin_methods -> LENGTH LPAREN clist RPAREN
Rule 72    builtin_methods -> EXIT LPAREN clist RPAREN
Rule 73    single_if -> IF LCURLYEBR error RCURLYEBR stmt
Rule 74    while_loop -> WHILE LPAREN error RPAREN stmt
Rule 75    func1_rtype -> FN ID LPAREN flist RPAREN LESS_THAN error GREATER_THAN LCURLYEBR body RCURLYEBR
Rule 76    func2_rtype -> FN ID LPAREN flist RPAREN LESS_THAN error GREATER_THAN EQ GREATER_THAN return_is
Rule 77    func_flist -> FN ID LPAREN error RPAREN LCURLYEBR body RCURLYEBR
Rule 78    else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
Rule 79    for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt
Rule 80    for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt
Rule 81    for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt
Rule 82    defvar_type -> ID DBL_COLON error
Rule 83    defvar_type -> ID DBL_COLON error EQ expr
Rule 84    flist -> ID AS error
Rule 85    flist -> ID AS error COMMA flist
Rule 86    flist -> error AS type
Rule 87    flist -> error AS type COMMA flist
Rule 88    flist -> ID AS type COMMA error

Terminals, with rules where they appear

AND                  : 64
ARRAY                : 
AS                   : 35 36 84 85 86 87 88
BEGIN                : 22
BOOLEAN              : 31
COLON                : 52
COMMA                : 36 39 85 87 88
DBL_COLON            : 25 26 82 83
DIVIDE               : 57
DO                   : 21
DOUBLE_EQ            : 60
DOUBLE_LSQUAREBR     : 21 23 24 78
DOUBLE_RSQUAREBR     : 21 23 24 78
ELSE                 : 24 78
ELSEIF               : 
END                  : 22
EQ                   : 20 26 33 49 76 79 80 81 83
EXIT                 : 72
FALSE                : 
FN                   : 32 33 75 76 77
FOR                  : 20 79 80 81
GREATER_THAN         : 32 33 33 58 75 76 76
GREATER_THAN_EQ      : 61
ID                   : 20 25 26 32 33 35 36 44 49 53 75 76 77 79 80 81 82 83 84 85 88
IF                   : 23 24 73 78
INT                  : 27
LCURLYEBR            : 32 73 75 77
LENGTH               : 71
LESS_THAN            : 32 33 59 75 76
LESS_THAN_EQ         : 62
LIST                 : 
LPAREN               : 19 20 32 33 53 69 70 71 72 74 75 76 77 79 80 81
LSQUAREBR            : 50 51
MINUS                : 55 68
NOT                  : 66
NOT_EQ               : 63
NULL                 : 30
NUMBER               : 47
OR                   : 65
PLUS                 : 54 67
PRINT                : 70
QUESTION_MARK        : 52
RCURLYEBR            : 32 73 75 77
RETURN               : 18
RPAREN               : 19 20 32 33 53 69 70 71 72 74 75 76 77 79 80 81
RSQUAREBR            : 50 51
SCAN                 : 69
SEMI_COLON           : 6 7 8 14
STRING               : 28 48
TIMES                : 56
TO                   : 20 79 80 81
TRUE                 : 
VECTOR               : 29
WHILE                : 19 21 74
error                : 73 74 75 76 77 78 79 80 81 81 82 83 84 85 86 87 88

Nonterminals, with rules where they appear

assignment           : 45
binary_expr          : 43
block                : 15
body                 : 17 22 32 75 77
builtin_methods      : 
clist                : 39 51 53 70 71 72
defvar               : 7
defvar_type          : 
do_while             : 13
else_if              : 10
empty                : 1 16 34 37
expr                 : 6 18 19 20 20 21 23 24 26 38 39 49 50 50 52 52 52 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 67 68 79 80 83
expr_list            : 41
flist                : 32 33 36 75 76 85 87
for_loop             : 12
func                 : 2 8
func1                : 3
func1_rtype          : 
func2                : 4
func2_rtype          : 
func_flist           : 
function_call        : 46
on_list              : 40
prog                 : 2 0
return_is            : 14 33 76
single_if            : 9
stmt                 : 17 19 20 21 23 24 24 73 74 78 78 79 80 81
ternary_expr         : 42
type                 : 25 26 32 33 35 36 86 87 88
while_loop           : 11

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (5) empty -> .
    (3) func -> . func1
    (4) func -> . func2
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    $end            reduce using rule 5 (empty -> .)
    FN              shift and go to state 6

    prog                           shift and go to state 1
    empty                          shift and go to state 2
    func                           shift and go to state 3
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> empty .

    $end            reduce using rule 1 (prog -> empty .)


state 3

    (2) prog -> func . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (5) empty -> .
    (3) func -> . func1
    (4) func -> . func2
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    $end            reduce using rule 5 (empty -> .)
    FN              shift and go to state 6

    func                           shift and go to state 3
    prog                           shift and go to state 7
    empty                          shift and go to state 2
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 4

    (3) func -> func1 .

    FN              reduce using rule 3 (func -> func1 .)
    $end            reduce using rule 3 (func -> func1 .)
    SEMI_COLON      reduce using rule 3 (func -> func1 .)


state 5

    (4) func -> func2 .

    FN              reduce using rule 4 (func -> func2 .)
    $end            reduce using rule 4 (func -> func2 .)
    SEMI_COLON      reduce using rule 4 (func -> func2 .)


state 6

    (32) func1 -> FN . ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN . ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 8


state 7

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)


state 8

    (32) func1 -> FN ID . LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID . LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    LPAREN          shift and go to state 9


state 9

    (32) func1 -> FN ID LPAREN . flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN . flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (34) flist -> . empty
    (35) flist -> . ID AS type
    (36) flist -> . ID AS type COMMA flist
    (84) flist -> . ID AS error
    (85) flist -> . ID AS error COMMA flist
    (86) flist -> . error AS type
    (87) flist -> . error AS type COMMA flist
    (88) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 11
    empty                          shift and go to state 12

state 10

    (35) flist -> ID . AS type
    (36) flist -> ID . AS type COMMA flist
    (84) flist -> ID . AS error
    (85) flist -> ID . AS error COMMA flist
    (88) flist -> ID . AS type COMMA error

    AS              shift and go to state 14


state 11

    (32) func1 -> FN ID LPAREN flist . RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN flist . RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    RPAREN          shift and go to state 15


state 12

    (34) flist -> empty .

    RPAREN          reduce using rule 34 (flist -> empty .)


state 13

    (86) flist -> error . AS type
    (87) flist -> error . AS type COMMA flist

    AS              shift and go to state 16


state 14

    (35) flist -> ID AS . type
    (36) flist -> ID AS . type COMMA flist
    (84) flist -> ID AS . error
    (85) flist -> ID AS . error COMMA flist
    (88) flist -> ID AS . type COMMA error
    (27) type -> . INT
    (28) type -> . STRING
    (29) type -> . VECTOR
    (30) type -> . NULL
    (31) type -> . BOOLEAN

    error           shift and go to state 18
    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 17

state 15

    (32) func1 -> FN ID LPAREN flist RPAREN . LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN flist RPAREN . LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    LESS_THAN       shift and go to state 24


state 16

    (86) flist -> error AS . type
    (87) flist -> error AS . type COMMA flist
    (27) type -> . INT
    (28) type -> . STRING
    (29) type -> . VECTOR
    (30) type -> . NULL
    (31) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 25

state 17

    (35) flist -> ID AS type .
    (36) flist -> ID AS type . COMMA flist
    (88) flist -> ID AS type . COMMA error

    RPAREN          reduce using rule 35 (flist -> ID AS type .)
    COMMA           shift and go to state 26


state 18

    (84) flist -> ID AS error .
    (85) flist -> ID AS error . COMMA flist

    RPAREN          reduce using rule 84 (flist -> ID AS error .)
    COMMA           shift and go to state 27


state 19

    (27) type -> INT .

    COMMA           reduce using rule 27 (type -> INT .)
    RPAREN          reduce using rule 27 (type -> INT .)
    GREATER_THAN    reduce using rule 27 (type -> INT .)
    EQ              reduce using rule 27 (type -> INT .)
    SEMI_COLON      reduce using rule 27 (type -> INT .)


state 20

    (28) type -> STRING .

    COMMA           reduce using rule 28 (type -> STRING .)
    RPAREN          reduce using rule 28 (type -> STRING .)
    GREATER_THAN    reduce using rule 28 (type -> STRING .)
    EQ              reduce using rule 28 (type -> STRING .)
    SEMI_COLON      reduce using rule 28 (type -> STRING .)


state 21

    (29) type -> VECTOR .

    COMMA           reduce using rule 29 (type -> VECTOR .)
    RPAREN          reduce using rule 29 (type -> VECTOR .)
    GREATER_THAN    reduce using rule 29 (type -> VECTOR .)
    EQ              reduce using rule 29 (type -> VECTOR .)
    SEMI_COLON      reduce using rule 29 (type -> VECTOR .)


state 22

    (30) type -> NULL .

    COMMA           reduce using rule 30 (type -> NULL .)
    RPAREN          reduce using rule 30 (type -> NULL .)
    GREATER_THAN    reduce using rule 30 (type -> NULL .)
    EQ              reduce using rule 30 (type -> NULL .)
    SEMI_COLON      reduce using rule 30 (type -> NULL .)


state 23

    (31) type -> BOOLEAN .

    COMMA           reduce using rule 31 (type -> BOOLEAN .)
    RPAREN          reduce using rule 31 (type -> BOOLEAN .)
    GREATER_THAN    reduce using rule 31 (type -> BOOLEAN .)
    EQ              reduce using rule 31 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 31 (type -> BOOLEAN .)


state 24

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN . type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN . type GREATER_THAN EQ GREATER_THAN return_is
    (27) type -> . INT
    (28) type -> . STRING
    (29) type -> . VECTOR
    (30) type -> . NULL
    (31) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 28

state 25

    (86) flist -> error AS type .
    (87) flist -> error AS type . COMMA flist

    RPAREN          reduce using rule 86 (flist -> error AS type .)
    COMMA           shift and go to state 29


state 26

    (36) flist -> ID AS type COMMA . flist
    (88) flist -> ID AS type COMMA . error
    (34) flist -> . empty
    (35) flist -> . ID AS type
    (36) flist -> . ID AS type COMMA flist
    (84) flist -> . ID AS error
    (85) flist -> . ID AS error COMMA flist
    (86) flist -> . error AS type
    (87) flist -> . error AS type COMMA flist
    (88) flist -> . ID AS type COMMA error
    (5) empty -> .

    error           shift and go to state 31
    ID              shift and go to state 10
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 30
    empty                          shift and go to state 12

state 27

    (85) flist -> ID AS error COMMA . flist
    (34) flist -> . empty
    (35) flist -> . ID AS type
    (36) flist -> . ID AS type COMMA flist
    (84) flist -> . ID AS error
    (85) flist -> . ID AS error COMMA flist
    (86) flist -> . error AS type
    (87) flist -> . error AS type COMMA flist
    (88) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 32
    empty                          shift and go to state 12

state 28

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type . GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type . GREATER_THAN EQ GREATER_THAN return_is

    GREATER_THAN    shift and go to state 33


state 29

    (87) flist -> error AS type COMMA . flist
    (34) flist -> . empty
    (35) flist -> . ID AS type
    (36) flist -> . ID AS type COMMA flist
    (84) flist -> . ID AS error
    (85) flist -> . ID AS error COMMA flist
    (86) flist -> . error AS type
    (87) flist -> . error AS type COMMA flist
    (88) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 34
    empty                          shift and go to state 12

state 30

    (36) flist -> ID AS type COMMA flist .

    RPAREN          reduce using rule 36 (flist -> ID AS type COMMA flist .)


state 31

    (88) flist -> ID AS type COMMA error .
    (86) flist -> error . AS type
    (87) flist -> error . AS type COMMA flist

    RPAREN          reduce using rule 88 (flist -> ID AS type COMMA error .)
    AS              shift and go to state 16


state 32

    (85) flist -> ID AS error COMMA flist .

    RPAREN          reduce using rule 85 (flist -> ID AS error COMMA flist .)


state 33

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN . LCURLYEBR body RCURLYEBR
    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN . EQ GREATER_THAN return_is

    LCURLYEBR       shift and go to state 35
    EQ              shift and go to state 36


state 34

    (87) flist -> error AS type COMMA flist .

    RPAREN          reduce using rule 87 (flist -> error AS type COMMA flist .)


state 35

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR . body RCURLYEBR
    (16) body -> . empty
    (17) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    RCURLYEBR       reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    body                           shift and go to state 38
    empty                          shift and go to state 39
    stmt                           shift and go to state 40
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 36

    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ . GREATER_THAN return_is

    GREATER_THAN    shift and go to state 69


state 37

    (44) expr -> ID .
    (25) defvar -> ID . DBL_COLON type
    (26) defvar -> ID . DBL_COLON type EQ expr
    (49) assignment -> ID . EQ expr
    (53) function_call -> ID . LPAREN clist RPAREN

    SEMI_COLON      reduce using rule 44 (expr -> ID .)
    LSQUAREBR       reduce using rule 44 (expr -> ID .)
    QUESTION_MARK   reduce using rule 44 (expr -> ID .)
    PLUS            reduce using rule 44 (expr -> ID .)
    MINUS           reduce using rule 44 (expr -> ID .)
    TIMES           reduce using rule 44 (expr -> ID .)
    DIVIDE          reduce using rule 44 (expr -> ID .)
    GREATER_THAN    reduce using rule 44 (expr -> ID .)
    LESS_THAN       reduce using rule 44 (expr -> ID .)
    DOUBLE_EQ       reduce using rule 44 (expr -> ID .)
    GREATER_THAN_EQ reduce using rule 44 (expr -> ID .)
    LESS_THAN_EQ    reduce using rule 44 (expr -> ID .)
    NOT_EQ          reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    DBL_COLON       shift and go to state 70
    EQ              shift and go to state 71
    LPAREN          shift and go to state 72


state 38

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body . RCURLYEBR

    RCURLYEBR       shift and go to state 73


state 39

    (16) body -> empty .

    RCURLYEBR       reduce using rule 16 (body -> empty .)
    END             reduce using rule 16 (body -> empty .)


state 40

    (17) body -> stmt . body
    (16) body -> . empty
    (17) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    RCURLYEBR       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 40
    body                           shift and go to state 74
    empty                          shift and go to state 39
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 41

    (6) stmt -> expr . SEMI_COLON
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    SEMI_COLON      shift and go to state 75
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 42

    (7) stmt -> defvar . SEMI_COLON

    SEMI_COLON      shift and go to state 90


state 43

    (8) stmt -> func . SEMI_COLON

    SEMI_COLON      shift and go to state 91


state 44

    (9) stmt -> single_if .

    ID              reduce using rule 9 (stmt -> single_if .)
    NUMBER          reduce using rule 9 (stmt -> single_if .)
    STRING          reduce using rule 9 (stmt -> single_if .)
    IF              reduce using rule 9 (stmt -> single_if .)
    WHILE           reduce using rule 9 (stmt -> single_if .)
    FOR             reduce using rule 9 (stmt -> single_if .)
    DO              reduce using rule 9 (stmt -> single_if .)
    RETURN          reduce using rule 9 (stmt -> single_if .)
    BEGIN           reduce using rule 9 (stmt -> single_if .)
    LSQUAREBR       reduce using rule 9 (stmt -> single_if .)
    NOT             reduce using rule 9 (stmt -> single_if .)
    PLUS            reduce using rule 9 (stmt -> single_if .)
    MINUS           reduce using rule 9 (stmt -> single_if .)
    FN              reduce using rule 9 (stmt -> single_if .)
    RCURLYEBR       reduce using rule 9 (stmt -> single_if .)
    END             reduce using rule 9 (stmt -> single_if .)
    ELSE            reduce using rule 9 (stmt -> single_if .)


state 45

    (10) stmt -> else_if .

    ID              reduce using rule 10 (stmt -> else_if .)
    NUMBER          reduce using rule 10 (stmt -> else_if .)
    STRING          reduce using rule 10 (stmt -> else_if .)
    IF              reduce using rule 10 (stmt -> else_if .)
    WHILE           reduce using rule 10 (stmt -> else_if .)
    FOR             reduce using rule 10 (stmt -> else_if .)
    DO              reduce using rule 10 (stmt -> else_if .)
    RETURN          reduce using rule 10 (stmt -> else_if .)
    BEGIN           reduce using rule 10 (stmt -> else_if .)
    LSQUAREBR       reduce using rule 10 (stmt -> else_if .)
    NOT             reduce using rule 10 (stmt -> else_if .)
    PLUS            reduce using rule 10 (stmt -> else_if .)
    MINUS           reduce using rule 10 (stmt -> else_if .)
    FN              reduce using rule 10 (stmt -> else_if .)
    RCURLYEBR       reduce using rule 10 (stmt -> else_if .)
    END             reduce using rule 10 (stmt -> else_if .)
    ELSE            reduce using rule 10 (stmt -> else_if .)


state 46

    (11) stmt -> while_loop .

    ID              reduce using rule 11 (stmt -> while_loop .)
    NUMBER          reduce using rule 11 (stmt -> while_loop .)
    STRING          reduce using rule 11 (stmt -> while_loop .)
    IF              reduce using rule 11 (stmt -> while_loop .)
    WHILE           reduce using rule 11 (stmt -> while_loop .)
    FOR             reduce using rule 11 (stmt -> while_loop .)
    DO              reduce using rule 11 (stmt -> while_loop .)
    RETURN          reduce using rule 11 (stmt -> while_loop .)
    BEGIN           reduce using rule 11 (stmt -> while_loop .)
    LSQUAREBR       reduce using rule 11 (stmt -> while_loop .)
    NOT             reduce using rule 11 (stmt -> while_loop .)
    PLUS            reduce using rule 11 (stmt -> while_loop .)
    MINUS           reduce using rule 11 (stmt -> while_loop .)
    FN              reduce using rule 11 (stmt -> while_loop .)
    RCURLYEBR       reduce using rule 11 (stmt -> while_loop .)
    END             reduce using rule 11 (stmt -> while_loop .)
    ELSE            reduce using rule 11 (stmt -> while_loop .)


state 47

    (12) stmt -> for_loop .

    ID              reduce using rule 12 (stmt -> for_loop .)
    NUMBER          reduce using rule 12 (stmt -> for_loop .)
    STRING          reduce using rule 12 (stmt -> for_loop .)
    IF              reduce using rule 12 (stmt -> for_loop .)
    WHILE           reduce using rule 12 (stmt -> for_loop .)
    FOR             reduce using rule 12 (stmt -> for_loop .)
    DO              reduce using rule 12 (stmt -> for_loop .)
    RETURN          reduce using rule 12 (stmt -> for_loop .)
    BEGIN           reduce using rule 12 (stmt -> for_loop .)
    LSQUAREBR       reduce using rule 12 (stmt -> for_loop .)
    NOT             reduce using rule 12 (stmt -> for_loop .)
    PLUS            reduce using rule 12 (stmt -> for_loop .)
    MINUS           reduce using rule 12 (stmt -> for_loop .)
    FN              reduce using rule 12 (stmt -> for_loop .)
    RCURLYEBR       reduce using rule 12 (stmt -> for_loop .)
    END             reduce using rule 12 (stmt -> for_loop .)
    ELSE            reduce using rule 12 (stmt -> for_loop .)


state 48

    (13) stmt -> do_while .

    ID              reduce using rule 13 (stmt -> do_while .)
    NUMBER          reduce using rule 13 (stmt -> do_while .)
    STRING          reduce using rule 13 (stmt -> do_while .)
    IF              reduce using rule 13 (stmt -> do_while .)
    WHILE           reduce using rule 13 (stmt -> do_while .)
    FOR             reduce using rule 13 (stmt -> do_while .)
    DO              reduce using rule 13 (stmt -> do_while .)
    RETURN          reduce using rule 13 (stmt -> do_while .)
    BEGIN           reduce using rule 13 (stmt -> do_while .)
    LSQUAREBR       reduce using rule 13 (stmt -> do_while .)
    NOT             reduce using rule 13 (stmt -> do_while .)
    PLUS            reduce using rule 13 (stmt -> do_while .)
    MINUS           reduce using rule 13 (stmt -> do_while .)
    FN              reduce using rule 13 (stmt -> do_while .)
    RCURLYEBR       reduce using rule 13 (stmt -> do_while .)
    END             reduce using rule 13 (stmt -> do_while .)
    ELSE            reduce using rule 13 (stmt -> do_while .)


state 49

    (14) stmt -> return_is . SEMI_COLON

    SEMI_COLON      shift and go to state 92


state 50

    (15) stmt -> block .

    ID              reduce using rule 15 (stmt -> block .)
    NUMBER          reduce using rule 15 (stmt -> block .)
    STRING          reduce using rule 15 (stmt -> block .)
    IF              reduce using rule 15 (stmt -> block .)
    WHILE           reduce using rule 15 (stmt -> block .)
    FOR             reduce using rule 15 (stmt -> block .)
    DO              reduce using rule 15 (stmt -> block .)
    RETURN          reduce using rule 15 (stmt -> block .)
    BEGIN           reduce using rule 15 (stmt -> block .)
    LSQUAREBR       reduce using rule 15 (stmt -> block .)
    NOT             reduce using rule 15 (stmt -> block .)
    PLUS            reduce using rule 15 (stmt -> block .)
    MINUS           reduce using rule 15 (stmt -> block .)
    FN              reduce using rule 15 (stmt -> block .)
    RCURLYEBR       reduce using rule 15 (stmt -> block .)
    END             reduce using rule 15 (stmt -> block .)
    ELSE            reduce using rule 15 (stmt -> block .)


state 51

    (40) expr -> on_list .

    SEMI_COLON      reduce using rule 40 (expr -> on_list .)
    LSQUAREBR       reduce using rule 40 (expr -> on_list .)
    QUESTION_MARK   reduce using rule 40 (expr -> on_list .)
    PLUS            reduce using rule 40 (expr -> on_list .)
    MINUS           reduce using rule 40 (expr -> on_list .)
    TIMES           reduce using rule 40 (expr -> on_list .)
    DIVIDE          reduce using rule 40 (expr -> on_list .)
    GREATER_THAN    reduce using rule 40 (expr -> on_list .)
    LESS_THAN       reduce using rule 40 (expr -> on_list .)
    DOUBLE_EQ       reduce using rule 40 (expr -> on_list .)
    GREATER_THAN_EQ reduce using rule 40 (expr -> on_list .)
    LESS_THAN_EQ    reduce using rule 40 (expr -> on_list .)
    NOT_EQ          reduce using rule 40 (expr -> on_list .)
    AND             reduce using rule 40 (expr -> on_list .)
    OR              reduce using rule 40 (expr -> on_list .)
    FN              reduce using rule 40 (expr -> on_list .)
    $end            reduce using rule 40 (expr -> on_list .)
    COMMA           reduce using rule 40 (expr -> on_list .)
    RSQUAREBR       reduce using rule 40 (expr -> on_list .)
    RPAREN          reduce using rule 40 (expr -> on_list .)
    COLON           reduce using rule 40 (expr -> on_list .)
    DOUBLE_RSQUAREBR reduce using rule 40 (expr -> on_list .)
    TO              reduce using rule 40 (expr -> on_list .)


state 52

    (41) expr -> expr_list .

    SEMI_COLON      reduce using rule 41 (expr -> expr_list .)
    LSQUAREBR       reduce using rule 41 (expr -> expr_list .)
    QUESTION_MARK   reduce using rule 41 (expr -> expr_list .)
    PLUS            reduce using rule 41 (expr -> expr_list .)
    MINUS           reduce using rule 41 (expr -> expr_list .)
    TIMES           reduce using rule 41 (expr -> expr_list .)
    DIVIDE          reduce using rule 41 (expr -> expr_list .)
    GREATER_THAN    reduce using rule 41 (expr -> expr_list .)
    LESS_THAN       reduce using rule 41 (expr -> expr_list .)
    DOUBLE_EQ       reduce using rule 41 (expr -> expr_list .)
    GREATER_THAN_EQ reduce using rule 41 (expr -> expr_list .)
    LESS_THAN_EQ    reduce using rule 41 (expr -> expr_list .)
    NOT_EQ          reduce using rule 41 (expr -> expr_list .)
    AND             reduce using rule 41 (expr -> expr_list .)
    OR              reduce using rule 41 (expr -> expr_list .)
    FN              reduce using rule 41 (expr -> expr_list .)
    $end            reduce using rule 41 (expr -> expr_list .)
    COMMA           reduce using rule 41 (expr -> expr_list .)
    RSQUAREBR       reduce using rule 41 (expr -> expr_list .)
    RPAREN          reduce using rule 41 (expr -> expr_list .)
    COLON           reduce using rule 41 (expr -> expr_list .)
    DOUBLE_RSQUAREBR reduce using rule 41 (expr -> expr_list .)
    TO              reduce using rule 41 (expr -> expr_list .)


state 53

    (42) expr -> ternary_expr .

    SEMI_COLON      reduce using rule 42 (expr -> ternary_expr .)
    LSQUAREBR       reduce using rule 42 (expr -> ternary_expr .)
    QUESTION_MARK   reduce using rule 42 (expr -> ternary_expr .)
    PLUS            reduce using rule 42 (expr -> ternary_expr .)
    MINUS           reduce using rule 42 (expr -> ternary_expr .)
    TIMES           reduce using rule 42 (expr -> ternary_expr .)
    DIVIDE          reduce using rule 42 (expr -> ternary_expr .)
    GREATER_THAN    reduce using rule 42 (expr -> ternary_expr .)
    LESS_THAN       reduce using rule 42 (expr -> ternary_expr .)
    DOUBLE_EQ       reduce using rule 42 (expr -> ternary_expr .)
    GREATER_THAN_EQ reduce using rule 42 (expr -> ternary_expr .)
    LESS_THAN_EQ    reduce using rule 42 (expr -> ternary_expr .)
    NOT_EQ          reduce using rule 42 (expr -> ternary_expr .)
    AND             reduce using rule 42 (expr -> ternary_expr .)
    OR              reduce using rule 42 (expr -> ternary_expr .)
    FN              reduce using rule 42 (expr -> ternary_expr .)
    $end            reduce using rule 42 (expr -> ternary_expr .)
    COMMA           reduce using rule 42 (expr -> ternary_expr .)
    RSQUAREBR       reduce using rule 42 (expr -> ternary_expr .)
    RPAREN          reduce using rule 42 (expr -> ternary_expr .)
    COLON           reduce using rule 42 (expr -> ternary_expr .)
    DOUBLE_RSQUAREBR reduce using rule 42 (expr -> ternary_expr .)
    TO              reduce using rule 42 (expr -> ternary_expr .)


state 54

    (43) expr -> binary_expr .

    SEMI_COLON      reduce using rule 43 (expr -> binary_expr .)
    LSQUAREBR       reduce using rule 43 (expr -> binary_expr .)
    QUESTION_MARK   reduce using rule 43 (expr -> binary_expr .)
    PLUS            reduce using rule 43 (expr -> binary_expr .)
    MINUS           reduce using rule 43 (expr -> binary_expr .)
    TIMES           reduce using rule 43 (expr -> binary_expr .)
    DIVIDE          reduce using rule 43 (expr -> binary_expr .)
    GREATER_THAN    reduce using rule 43 (expr -> binary_expr .)
    LESS_THAN       reduce using rule 43 (expr -> binary_expr .)
    DOUBLE_EQ       reduce using rule 43 (expr -> binary_expr .)
    GREATER_THAN_EQ reduce using rule 43 (expr -> binary_expr .)
    LESS_THAN_EQ    reduce using rule 43 (expr -> binary_expr .)
    NOT_EQ          reduce using rule 43 (expr -> binary_expr .)
    AND             reduce using rule 43 (expr -> binary_expr .)
    OR              reduce using rule 43 (expr -> binary_expr .)
    FN              reduce using rule 43 (expr -> binary_expr .)
    $end            reduce using rule 43 (expr -> binary_expr .)
    COMMA           reduce using rule 43 (expr -> binary_expr .)
    RSQUAREBR       reduce using rule 43 (expr -> binary_expr .)
    RPAREN          reduce using rule 43 (expr -> binary_expr .)
    COLON           reduce using rule 43 (expr -> binary_expr .)
    DOUBLE_RSQUAREBR reduce using rule 43 (expr -> binary_expr .)
    TO              reduce using rule 43 (expr -> binary_expr .)


state 55

    (45) expr -> assignment .

    SEMI_COLON      reduce using rule 45 (expr -> assignment .)
    LSQUAREBR       reduce using rule 45 (expr -> assignment .)
    QUESTION_MARK   reduce using rule 45 (expr -> assignment .)
    PLUS            reduce using rule 45 (expr -> assignment .)
    MINUS           reduce using rule 45 (expr -> assignment .)
    TIMES           reduce using rule 45 (expr -> assignment .)
    DIVIDE          reduce using rule 45 (expr -> assignment .)
    GREATER_THAN    reduce using rule 45 (expr -> assignment .)
    LESS_THAN       reduce using rule 45 (expr -> assignment .)
    DOUBLE_EQ       reduce using rule 45 (expr -> assignment .)
    GREATER_THAN_EQ reduce using rule 45 (expr -> assignment .)
    LESS_THAN_EQ    reduce using rule 45 (expr -> assignment .)
    NOT_EQ          reduce using rule 45 (expr -> assignment .)
    AND             reduce using rule 45 (expr -> assignment .)
    OR              reduce using rule 45 (expr -> assignment .)
    FN              reduce using rule 45 (expr -> assignment .)
    $end            reduce using rule 45 (expr -> assignment .)
    COMMA           reduce using rule 45 (expr -> assignment .)
    RSQUAREBR       reduce using rule 45 (expr -> assignment .)
    RPAREN          reduce using rule 45 (expr -> assignment .)
    COLON           reduce using rule 45 (expr -> assignment .)
    DOUBLE_RSQUAREBR reduce using rule 45 (expr -> assignment .)
    TO              reduce using rule 45 (expr -> assignment .)


state 56

    (46) expr -> function_call .

    SEMI_COLON      reduce using rule 46 (expr -> function_call .)
    LSQUAREBR       reduce using rule 46 (expr -> function_call .)
    QUESTION_MARK   reduce using rule 46 (expr -> function_call .)
    PLUS            reduce using rule 46 (expr -> function_call .)
    MINUS           reduce using rule 46 (expr -> function_call .)
    TIMES           reduce using rule 46 (expr -> function_call .)
    DIVIDE          reduce using rule 46 (expr -> function_call .)
    GREATER_THAN    reduce using rule 46 (expr -> function_call .)
    LESS_THAN       reduce using rule 46 (expr -> function_call .)
    DOUBLE_EQ       reduce using rule 46 (expr -> function_call .)
    GREATER_THAN_EQ reduce using rule 46 (expr -> function_call .)
    LESS_THAN_EQ    reduce using rule 46 (expr -> function_call .)
    NOT_EQ          reduce using rule 46 (expr -> function_call .)
    AND             reduce using rule 46 (expr -> function_call .)
    OR              reduce using rule 46 (expr -> function_call .)
    FN              reduce using rule 46 (expr -> function_call .)
    $end            reduce using rule 46 (expr -> function_call .)
    COMMA           reduce using rule 46 (expr -> function_call .)
    RSQUAREBR       reduce using rule 46 (expr -> function_call .)
    RPAREN          reduce using rule 46 (expr -> function_call .)
    COLON           reduce using rule 46 (expr -> function_call .)
    DOUBLE_RSQUAREBR reduce using rule 46 (expr -> function_call .)
    TO              reduce using rule 46 (expr -> function_call .)


state 57

    (47) expr -> NUMBER .

    SEMI_COLON      reduce using rule 47 (expr -> NUMBER .)
    LSQUAREBR       reduce using rule 47 (expr -> NUMBER .)
    QUESTION_MARK   reduce using rule 47 (expr -> NUMBER .)
    PLUS            reduce using rule 47 (expr -> NUMBER .)
    MINUS           reduce using rule 47 (expr -> NUMBER .)
    TIMES           reduce using rule 47 (expr -> NUMBER .)
    DIVIDE          reduce using rule 47 (expr -> NUMBER .)
    GREATER_THAN    reduce using rule 47 (expr -> NUMBER .)
    LESS_THAN       reduce using rule 47 (expr -> NUMBER .)
    DOUBLE_EQ       reduce using rule 47 (expr -> NUMBER .)
    GREATER_THAN_EQ reduce using rule 47 (expr -> NUMBER .)
    LESS_THAN_EQ    reduce using rule 47 (expr -> NUMBER .)
    NOT_EQ          reduce using rule 47 (expr -> NUMBER .)
    AND             reduce using rule 47 (expr -> NUMBER .)
    OR              reduce using rule 47 (expr -> NUMBER .)
    FN              reduce using rule 47 (expr -> NUMBER .)
    $end            reduce using rule 47 (expr -> NUMBER .)
    COMMA           reduce using rule 47 (expr -> NUMBER .)
    RSQUAREBR       reduce using rule 47 (expr -> NUMBER .)
    RPAREN          reduce using rule 47 (expr -> NUMBER .)
    COLON           reduce using rule 47 (expr -> NUMBER .)
    DOUBLE_RSQUAREBR reduce using rule 47 (expr -> NUMBER .)
    TO              reduce using rule 47 (expr -> NUMBER .)


state 58

    (48) expr -> STRING .

    SEMI_COLON      reduce using rule 48 (expr -> STRING .)
    LSQUAREBR       reduce using rule 48 (expr -> STRING .)
    QUESTION_MARK   reduce using rule 48 (expr -> STRING .)
    PLUS            reduce using rule 48 (expr -> STRING .)
    MINUS           reduce using rule 48 (expr -> STRING .)
    TIMES           reduce using rule 48 (expr -> STRING .)
    DIVIDE          reduce using rule 48 (expr -> STRING .)
    GREATER_THAN    reduce using rule 48 (expr -> STRING .)
    LESS_THAN       reduce using rule 48 (expr -> STRING .)
    DOUBLE_EQ       reduce using rule 48 (expr -> STRING .)
    GREATER_THAN_EQ reduce using rule 48 (expr -> STRING .)
    LESS_THAN_EQ    reduce using rule 48 (expr -> STRING .)
    NOT_EQ          reduce using rule 48 (expr -> STRING .)
    AND             reduce using rule 48 (expr -> STRING .)
    OR              reduce using rule 48 (expr -> STRING .)
    FN              reduce using rule 48 (expr -> STRING .)
    $end            reduce using rule 48 (expr -> STRING .)
    COMMA           reduce using rule 48 (expr -> STRING .)
    RSQUAREBR       reduce using rule 48 (expr -> STRING .)
    RPAREN          reduce using rule 48 (expr -> STRING .)
    COLON           reduce using rule 48 (expr -> STRING .)
    DOUBLE_RSQUAREBR reduce using rule 48 (expr -> STRING .)
    TO              reduce using rule 48 (expr -> STRING .)


state 59

    (23) single_if -> IF . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> IF . LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> IF . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> IF . DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt

    DOUBLE_LSQUAREBR shift and go to state 93
    LCURLYEBR       shift and go to state 94


state 60

    (19) while_loop -> WHILE . LPAREN expr RPAREN stmt
    (74) while_loop -> WHILE . LPAREN error RPAREN stmt

    LPAREN          shift and go to state 95


state 61

    (20) for_loop -> FOR . LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> FOR . LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> FOR . LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> FOR . LPAREN ID EQ error TO error RPAREN stmt

    LPAREN          shift and go to state 96


state 62

    (21) do_while -> DO . stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 97
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 63

    (18) return_is -> RETURN . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 98
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 64

    (22) block -> BEGIN . body END
    (16) body -> . empty
    (17) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    END             reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    body                           shift and go to state 100
    empty                          shift and go to state 39
    stmt                           shift and go to state 40
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 65

    (51) expr_list -> LSQUAREBR . clist RSQUAREBR
    (37) clist -> . empty
    (38) clist -> . expr
    (39) clist -> . expr COMMA clist
    (5) empty -> .
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    RSQUAREBR       reduce using rule 5 (empty -> .)
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    clist                          shift and go to state 101
    empty                          shift and go to state 102
    expr                           shift and go to state 103
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 66

    (67) binary_expr -> PLUS . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 104
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 67

    (68) binary_expr -> MINUS . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 105
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 68

    (66) binary_expr -> NOT . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 106
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 69

    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN . return_is
    (18) return_is -> . RETURN expr

    RETURN          shift and go to state 63

    return_is                      shift and go to state 107

state 70

    (25) defvar -> ID DBL_COLON . type
    (26) defvar -> ID DBL_COLON . type EQ expr
    (27) type -> . INT
    (28) type -> . STRING
    (29) type -> . VECTOR
    (30) type -> . NULL
    (31) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 108

state 71

    (49) assignment -> ID EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 109
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 72

    (53) function_call -> ID LPAREN . clist RPAREN
    (37) clist -> . empty
    (38) clist -> . expr
    (39) clist -> . expr COMMA clist
    (5) empty -> .
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    clist                          shift and go to state 110
    empty                          shift and go to state 102
    expr                           shift and go to state 103
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 73

    (32) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .

    FN              reduce using rule 32 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    $end            reduce using rule 32 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    SEMI_COLON      reduce using rule 32 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)


state 74

    (17) body -> stmt body .

    RCURLYEBR       reduce using rule 17 (body -> stmt body .)
    END             reduce using rule 17 (body -> stmt body .)


state 75

    (6) stmt -> expr SEMI_COLON .

    ID              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    NUMBER          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    STRING          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    IF              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    WHILE           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    FOR             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    DO              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    RETURN          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    BEGIN           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    LSQUAREBR       reduce using rule 6 (stmt -> expr SEMI_COLON .)
    NOT             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    PLUS            reduce using rule 6 (stmt -> expr SEMI_COLON .)
    MINUS           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    FN              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    RCURLYEBR       reduce using rule 6 (stmt -> expr SEMI_COLON .)
    END             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    ELSE            reduce using rule 6 (stmt -> expr SEMI_COLON .)


state 76

    (50) on_list -> expr LSQUAREBR . expr RSQUAREBR
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 111
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 77

    (52) ternary_expr -> expr QUESTION_MARK . expr COLON expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 112
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 78

    (54) binary_expr -> expr PLUS . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 113
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 79

    (55) binary_expr -> expr MINUS . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 114
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 80

    (56) binary_expr -> expr TIMES . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 115
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 81

    (57) binary_expr -> expr DIVIDE . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 116
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 82

    (58) binary_expr -> expr GREATER_THAN . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 117
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 83

    (59) binary_expr -> expr LESS_THAN . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 118
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 84

    (60) binary_expr -> expr DOUBLE_EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 119
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 85

    (61) binary_expr -> expr GREATER_THAN_EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 120
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 86

    (62) binary_expr -> expr LESS_THAN_EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 121
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 87

    (63) binary_expr -> expr NOT_EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 122
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 88

    (64) binary_expr -> expr AND . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 123
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 89

    (65) binary_expr -> expr OR . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 124
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 90

    (7) stmt -> defvar SEMI_COLON .

    ID              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    NUMBER          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    STRING          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    IF              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    WHILE           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    FOR             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    DO              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    RETURN          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    BEGIN           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    LSQUAREBR       reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    NOT             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    PLUS            reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    MINUS           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    FN              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    RCURLYEBR       reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    END             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    ELSE            reduce using rule 7 (stmt -> defvar SEMI_COLON .)


state 91

    (8) stmt -> func SEMI_COLON .

    ID              reduce using rule 8 (stmt -> func SEMI_COLON .)
    NUMBER          reduce using rule 8 (stmt -> func SEMI_COLON .)
    STRING          reduce using rule 8 (stmt -> func SEMI_COLON .)
    IF              reduce using rule 8 (stmt -> func SEMI_COLON .)
    WHILE           reduce using rule 8 (stmt -> func SEMI_COLON .)
    FOR             reduce using rule 8 (stmt -> func SEMI_COLON .)
    DO              reduce using rule 8 (stmt -> func SEMI_COLON .)
    RETURN          reduce using rule 8 (stmt -> func SEMI_COLON .)
    BEGIN           reduce using rule 8 (stmt -> func SEMI_COLON .)
    LSQUAREBR       reduce using rule 8 (stmt -> func SEMI_COLON .)
    NOT             reduce using rule 8 (stmt -> func SEMI_COLON .)
    PLUS            reduce using rule 8 (stmt -> func SEMI_COLON .)
    MINUS           reduce using rule 8 (stmt -> func SEMI_COLON .)
    FN              reduce using rule 8 (stmt -> func SEMI_COLON .)
    RCURLYEBR       reduce using rule 8 (stmt -> func SEMI_COLON .)
    END             reduce using rule 8 (stmt -> func SEMI_COLON .)
    ELSE            reduce using rule 8 (stmt -> func SEMI_COLON .)


state 92

    (14) stmt -> return_is SEMI_COLON .

    ID              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    NUMBER          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    STRING          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    IF              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    WHILE           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    FOR             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    DO              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    RETURN          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    BEGIN           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    LSQUAREBR       reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    NOT             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    PLUS            reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    MINUS           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    FN              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    RCURLYEBR       reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    END             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    ELSE            reduce using rule 14 (stmt -> return_is SEMI_COLON .)


state 93

    (23) single_if -> IF DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR stmt
    (24) else_if -> IF DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> IF DOUBLE_LSQUAREBR . error DOUBLE_RSQUAREBR stmt ELSE stmt
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 126
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 125
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 94

    (73) single_if -> IF LCURLYEBR . error RCURLYEBR stmt

    error           shift and go to state 127


state 95

    (19) while_loop -> WHILE LPAREN . expr RPAREN stmt
    (74) while_loop -> WHILE LPAREN . error RPAREN stmt
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 129
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 128
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 96

    (20) for_loop -> FOR LPAREN . ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> FOR LPAREN . ID EQ error TO expr RPAREN stmt
    (80) for_loop -> FOR LPAREN . ID EQ expr TO error RPAREN stmt
    (81) for_loop -> FOR LPAREN . ID EQ error TO error RPAREN stmt

    ID              shift and go to state 130


state 97

    (21) do_while -> DO stmt . WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR

    WHILE           shift and go to state 131


state 98

    (18) return_is -> RETURN expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    SEMI_COLON      reduce using rule 18 (return_is -> RETURN expr .)
    FN              reduce using rule 18 (return_is -> RETURN expr .)
    $end            reduce using rule 18 (return_is -> RETURN expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 99

    (44) expr -> ID .
    (49) assignment -> ID . EQ expr
    (53) function_call -> ID . LPAREN clist RPAREN

    LSQUAREBR       reduce using rule 44 (expr -> ID .)
    QUESTION_MARK   reduce using rule 44 (expr -> ID .)
    PLUS            reduce using rule 44 (expr -> ID .)
    MINUS           reduce using rule 44 (expr -> ID .)
    TIMES           reduce using rule 44 (expr -> ID .)
    DIVIDE          reduce using rule 44 (expr -> ID .)
    GREATER_THAN    reduce using rule 44 (expr -> ID .)
    LESS_THAN       reduce using rule 44 (expr -> ID .)
    DOUBLE_EQ       reduce using rule 44 (expr -> ID .)
    GREATER_THAN_EQ reduce using rule 44 (expr -> ID .)
    LESS_THAN_EQ    reduce using rule 44 (expr -> ID .)
    NOT_EQ          reduce using rule 44 (expr -> ID .)
    AND             reduce using rule 44 (expr -> ID .)
    OR              reduce using rule 44 (expr -> ID .)
    SEMI_COLON      reduce using rule 44 (expr -> ID .)
    FN              reduce using rule 44 (expr -> ID .)
    $end            reduce using rule 44 (expr -> ID .)
    COMMA           reduce using rule 44 (expr -> ID .)
    RSQUAREBR       reduce using rule 44 (expr -> ID .)
    RPAREN          reduce using rule 44 (expr -> ID .)
    COLON           reduce using rule 44 (expr -> ID .)
    DOUBLE_RSQUAREBR reduce using rule 44 (expr -> ID .)
    TO              reduce using rule 44 (expr -> ID .)
    EQ              shift and go to state 71
    LPAREN          shift and go to state 72


state 100

    (22) block -> BEGIN body . END

    END             shift and go to state 132


state 101

    (51) expr_list -> LSQUAREBR clist . RSQUAREBR

    RSQUAREBR       shift and go to state 133


state 102

    (37) clist -> empty .

    RSQUAREBR       reduce using rule 37 (clist -> empty .)
    RPAREN          reduce using rule 37 (clist -> empty .)


state 103

    (38) clist -> expr .
    (39) clist -> expr . COMMA clist
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    RSQUAREBR       reduce using rule 38 (clist -> expr .)
    RPAREN          reduce using rule 38 (clist -> expr .)
    COMMA           shift and go to state 134
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 104

    (67) binary_expr -> PLUS expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 67 (binary_expr -> PLUS expr .)
    FN              reduce using rule 67 (binary_expr -> PLUS expr .)
    $end            reduce using rule 67 (binary_expr -> PLUS expr .)
    COMMA           reduce using rule 67 (binary_expr -> PLUS expr .)
    RSQUAREBR       reduce using rule 67 (binary_expr -> PLUS expr .)
    RPAREN          reduce using rule 67 (binary_expr -> PLUS expr .)
    COLON           reduce using rule 67 (binary_expr -> PLUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 67 (binary_expr -> PLUS expr .)
    TO              reduce using rule 67 (binary_expr -> PLUS expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! PLUS            [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! MINUS           [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! TIMES           [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! LESS_THAN       [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! NOT_EQ          [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! AND             [ reduce using rule 67 (binary_expr -> PLUS expr .) ]
  ! OR              [ reduce using rule 67 (binary_expr -> PLUS expr .) ]


state 105

    (68) binary_expr -> MINUS expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 68 (binary_expr -> MINUS expr .)
    FN              reduce using rule 68 (binary_expr -> MINUS expr .)
    $end            reduce using rule 68 (binary_expr -> MINUS expr .)
    COMMA           reduce using rule 68 (binary_expr -> MINUS expr .)
    RSQUAREBR       reduce using rule 68 (binary_expr -> MINUS expr .)
    RPAREN          reduce using rule 68 (binary_expr -> MINUS expr .)
    COLON           reduce using rule 68 (binary_expr -> MINUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 68 (binary_expr -> MINUS expr .)
    TO              reduce using rule 68 (binary_expr -> MINUS expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! PLUS            [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! MINUS           [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! TIMES           [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! LESS_THAN       [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! NOT_EQ          [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! AND             [ reduce using rule 68 (binary_expr -> MINUS expr .) ]
  ! OR              [ reduce using rule 68 (binary_expr -> MINUS expr .) ]


state 106

    (66) binary_expr -> NOT expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 66 (binary_expr -> NOT expr .)
    FN              reduce using rule 66 (binary_expr -> NOT expr .)
    $end            reduce using rule 66 (binary_expr -> NOT expr .)
    COMMA           reduce using rule 66 (binary_expr -> NOT expr .)
    RSQUAREBR       reduce using rule 66 (binary_expr -> NOT expr .)
    RPAREN          reduce using rule 66 (binary_expr -> NOT expr .)
    COLON           reduce using rule 66 (binary_expr -> NOT expr .)
    DOUBLE_RSQUAREBR reduce using rule 66 (binary_expr -> NOT expr .)
    TO              reduce using rule 66 (binary_expr -> NOT expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! QUESTION_MARK   [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! PLUS            [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! MINUS           [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! TIMES           [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! GREATER_THAN    [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! LESS_THAN       [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! NOT_EQ          [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! AND             [ reduce using rule 66 (binary_expr -> NOT expr .) ]
  ! OR              [ reduce using rule 66 (binary_expr -> NOT expr .) ]


state 107

    (33) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .

    FN              reduce using rule 33 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    $end            reduce using rule 33 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    SEMI_COLON      reduce using rule 33 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)


state 108

    (25) defvar -> ID DBL_COLON type .
    (26) defvar -> ID DBL_COLON type . EQ expr

    SEMI_COLON      reduce using rule 25 (defvar -> ID DBL_COLON type .)
    EQ              shift and go to state 135


state 109

    (49) assignment -> ID EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 49 (assignment -> ID EQ expr .)
    FN              reduce using rule 49 (assignment -> ID EQ expr .)
    $end            reduce using rule 49 (assignment -> ID EQ expr .)
    COMMA           reduce using rule 49 (assignment -> ID EQ expr .)
    RSQUAREBR       reduce using rule 49 (assignment -> ID EQ expr .)
    RPAREN          reduce using rule 49 (assignment -> ID EQ expr .)
    COLON           reduce using rule 49 (assignment -> ID EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 49 (assignment -> ID EQ expr .)
    TO              reduce using rule 49 (assignment -> ID EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! PLUS            [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! MINUS           [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! TIMES           [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! DIVIDE          [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! AND             [ reduce using rule 49 (assignment -> ID EQ expr .) ]
  ! OR              [ reduce using rule 49 (assignment -> ID EQ expr .) ]


state 110

    (53) function_call -> ID LPAREN clist . RPAREN

    RPAREN          shift and go to state 136


state 111

    (50) on_list -> expr LSQUAREBR expr . RSQUAREBR
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    RSQUAREBR       shift and go to state 137
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 112

    (52) ternary_expr -> expr QUESTION_MARK expr . COLON expr
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    COLON           shift and go to state 138
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 113

    (54) binary_expr -> expr PLUS expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 54 (binary_expr -> expr PLUS expr .)
    FN              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    $end            reduce using rule 54 (binary_expr -> expr PLUS expr .)
    COMMA           reduce using rule 54 (binary_expr -> expr PLUS expr .)
    RSQUAREBR       reduce using rule 54 (binary_expr -> expr PLUS expr .)
    RPAREN          reduce using rule 54 (binary_expr -> expr PLUS expr .)
    COLON           reduce using rule 54 (binary_expr -> expr PLUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 54 (binary_expr -> expr PLUS expr .)
    TO              reduce using rule 54 (binary_expr -> expr PLUS expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! PLUS            [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! LESS_THAN       [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! NOT_EQ          [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! AND             [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]
  ! OR              [ reduce using rule 54 (binary_expr -> expr PLUS expr .) ]


state 114

    (55) binary_expr -> expr MINUS expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 55 (binary_expr -> expr MINUS expr .)
    FN              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    $end            reduce using rule 55 (binary_expr -> expr MINUS expr .)
    COMMA           reduce using rule 55 (binary_expr -> expr MINUS expr .)
    RSQUAREBR       reduce using rule 55 (binary_expr -> expr MINUS expr .)
    RPAREN          reduce using rule 55 (binary_expr -> expr MINUS expr .)
    COLON           reduce using rule 55 (binary_expr -> expr MINUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 55 (binary_expr -> expr MINUS expr .)
    TO              reduce using rule 55 (binary_expr -> expr MINUS expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! PLUS            [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! LESS_THAN       [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! NOT_EQ          [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 55 (binary_expr -> expr MINUS expr .) ]


state 115

    (56) binary_expr -> expr TIMES expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 56 (binary_expr -> expr TIMES expr .)
    FN              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    $end            reduce using rule 56 (binary_expr -> expr TIMES expr .)
    COMMA           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    RSQUAREBR       reduce using rule 56 (binary_expr -> expr TIMES expr .)
    RPAREN          reduce using rule 56 (binary_expr -> expr TIMES expr .)
    COLON           reduce using rule 56 (binary_expr -> expr TIMES expr .)
    DOUBLE_RSQUAREBR reduce using rule 56 (binary_expr -> expr TIMES expr .)
    TO              reduce using rule 56 (binary_expr -> expr TIMES expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! QUESTION_MARK   [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! PLUS            [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! MINUS           [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! TIMES           [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! DIVIDE          [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! GREATER_THAN    [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! LESS_THAN       [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! NOT_EQ          [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! AND             [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]
  ! OR              [ reduce using rule 56 (binary_expr -> expr TIMES expr .) ]


state 116

    (57) binary_expr -> expr DIVIDE expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    FN              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    $end            reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    RSQUAREBR       reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    COLON           reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    DOUBLE_RSQUAREBR reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    TO              reduce using rule 57 (binary_expr -> expr DIVIDE expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! QUESTION_MARK   [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! PLUS            [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! TIMES           [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! GREATER_THAN    [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! LESS_THAN       [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! NOT_EQ          [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! AND             [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]
  ! OR              [ reduce using rule 57 (binary_expr -> expr DIVIDE expr .) ]


state 117

    (58) binary_expr -> expr GREATER_THAN expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    FN              reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    $end            reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    COMMA           reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    RSQUAREBR       reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    RPAREN          reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    COLON           reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    DOUBLE_RSQUAREBR reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    TO              reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! QUESTION_MARK   [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! PLUS            [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! MINUS           [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! TIMES           [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! GREATER_THAN    [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! LESS_THAN       [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! NOT_EQ          [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! AND             [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]
  ! OR              [ reduce using rule 58 (binary_expr -> expr GREATER_THAN expr .) ]


state 118

    (59) binary_expr -> expr LESS_THAN expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    FN              reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    $end            reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    COMMA           reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    RSQUAREBR       reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    RPAREN          reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    COLON           reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    DOUBLE_RSQUAREBR reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    TO              reduce using rule 59 (binary_expr -> expr LESS_THAN expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! QUESTION_MARK   [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! PLUS            [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! MINUS           [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! TIMES           [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! GREATER_THAN    [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! LESS_THAN       [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! NOT_EQ          [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! AND             [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]
  ! OR              [ reduce using rule 59 (binary_expr -> expr LESS_THAN expr .) ]


state 119

    (60) binary_expr -> expr DOUBLE_EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    FN              reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    $end            reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    COMMA           reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    RSQUAREBR       reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    RPAREN          reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    COLON           reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    TO              reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! PLUS            [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! MINUS           [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! TIMES           [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! AND             [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! OR              [ reduce using rule 60 (binary_expr -> expr DOUBLE_EQ expr .) ]


state 120

    (61) binary_expr -> expr GREATER_THAN_EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    FN              reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    $end            reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    COMMA           reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RSQUAREBR       reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RPAREN          reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    COLON           reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    TO              reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! PLUS            [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! MINUS           [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! TIMES           [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! AND             [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! OR              [ reduce using rule 61 (binary_expr -> expr GREATER_THAN_EQ expr .) ]


state 121

    (62) binary_expr -> expr LESS_THAN_EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    FN              reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    $end            reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    COMMA           reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    RSQUAREBR       reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    RPAREN          reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    COLON           reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    TO              reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! PLUS            [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! MINUS           [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! TIMES           [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! AND             [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! OR              [ reduce using rule 62 (binary_expr -> expr LESS_THAN_EQ expr .) ]


state 122

    (63) binary_expr -> expr NOT_EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    FN              reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    $end            reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    COMMA           reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    RSQUAREBR       reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    RPAREN          reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    COLON           reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    TO              reduce using rule 63 (binary_expr -> expr NOT_EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! TIMES           [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! AND             [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]
  ! OR              [ reduce using rule 63 (binary_expr -> expr NOT_EQ expr .) ]


state 123

    (64) binary_expr -> expr AND expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 64 (binary_expr -> expr AND expr .)
    FN              reduce using rule 64 (binary_expr -> expr AND expr .)
    $end            reduce using rule 64 (binary_expr -> expr AND expr .)
    COMMA           reduce using rule 64 (binary_expr -> expr AND expr .)
    RSQUAREBR       reduce using rule 64 (binary_expr -> expr AND expr .)
    RPAREN          reduce using rule 64 (binary_expr -> expr AND expr .)
    COLON           reduce using rule 64 (binary_expr -> expr AND expr .)
    DOUBLE_RSQUAREBR reduce using rule 64 (binary_expr -> expr AND expr .)
    TO              reduce using rule 64 (binary_expr -> expr AND expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! QUESTION_MARK   [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! GREATER_THAN    [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! LESS_THAN       [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! NOT_EQ          [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! AND             [ reduce using rule 64 (binary_expr -> expr AND expr .) ]
  ! OR              [ reduce using rule 64 (binary_expr -> expr AND expr .) ]


state 124

    (65) binary_expr -> expr OR expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 65 (binary_expr -> expr OR expr .)
    FN              reduce using rule 65 (binary_expr -> expr OR expr .)
    $end            reduce using rule 65 (binary_expr -> expr OR expr .)
    COMMA           reduce using rule 65 (binary_expr -> expr OR expr .)
    RSQUAREBR       reduce using rule 65 (binary_expr -> expr OR expr .)
    RPAREN          reduce using rule 65 (binary_expr -> expr OR expr .)
    COLON           reduce using rule 65 (binary_expr -> expr OR expr .)
    DOUBLE_RSQUAREBR reduce using rule 65 (binary_expr -> expr OR expr .)
    TO              reduce using rule 65 (binary_expr -> expr OR expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! QUESTION_MARK   [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! GREATER_THAN    [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! LESS_THAN       [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! NOT_EQ          [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 65 (binary_expr -> expr OR expr .) ]
  ! OR              [ reduce using rule 65 (binary_expr -> expr OR expr .) ]


state 125

    (23) single_if -> IF DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR stmt
    (24) else_if -> IF DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR stmt ELSE stmt
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    DOUBLE_RSQUAREBR shift and go to state 139
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 126

    (78) else_if -> IF DOUBLE_LSQUAREBR error . DOUBLE_RSQUAREBR stmt ELSE stmt

    DOUBLE_RSQUAREBR shift and go to state 140


state 127

    (73) single_if -> IF LCURLYEBR error . RCURLYEBR stmt

    RCURLYEBR       shift and go to state 141


state 128

    (19) while_loop -> WHILE LPAREN expr . RPAREN stmt
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 142
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 129

    (74) while_loop -> WHILE LPAREN error . RPAREN stmt

    RPAREN          shift and go to state 143


state 130

    (20) for_loop -> FOR LPAREN ID . EQ expr TO expr RPAREN stmt
    (79) for_loop -> FOR LPAREN ID . EQ error TO expr RPAREN stmt
    (80) for_loop -> FOR LPAREN ID . EQ expr TO error RPAREN stmt
    (81) for_loop -> FOR LPAREN ID . EQ error TO error RPAREN stmt

    EQ              shift and go to state 144


state 131

    (21) do_while -> DO stmt WHILE . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR

    DOUBLE_LSQUAREBR shift and go to state 145


state 132

    (22) block -> BEGIN body END .

    ID              reduce using rule 22 (block -> BEGIN body END .)
    NUMBER          reduce using rule 22 (block -> BEGIN body END .)
    STRING          reduce using rule 22 (block -> BEGIN body END .)
    IF              reduce using rule 22 (block -> BEGIN body END .)
    WHILE           reduce using rule 22 (block -> BEGIN body END .)
    FOR             reduce using rule 22 (block -> BEGIN body END .)
    DO              reduce using rule 22 (block -> BEGIN body END .)
    RETURN          reduce using rule 22 (block -> BEGIN body END .)
    BEGIN           reduce using rule 22 (block -> BEGIN body END .)
    LSQUAREBR       reduce using rule 22 (block -> BEGIN body END .)
    NOT             reduce using rule 22 (block -> BEGIN body END .)
    PLUS            reduce using rule 22 (block -> BEGIN body END .)
    MINUS           reduce using rule 22 (block -> BEGIN body END .)
    FN              reduce using rule 22 (block -> BEGIN body END .)
    RCURLYEBR       reduce using rule 22 (block -> BEGIN body END .)
    END             reduce using rule 22 (block -> BEGIN body END .)
    ELSE            reduce using rule 22 (block -> BEGIN body END .)


state 133

    (51) expr_list -> LSQUAREBR clist RSQUAREBR .

    SEMI_COLON      reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LSQUAREBR       reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    QUESTION_MARK   reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    PLUS            reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    MINUS           reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    TIMES           reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DIVIDE          reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    GREATER_THAN    reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LESS_THAN       reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DOUBLE_EQ       reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    GREATER_THAN_EQ reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LESS_THAN_EQ    reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    NOT_EQ          reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    AND             reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    OR              reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    FN              reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    $end            reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    COMMA           reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RSQUAREBR       reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RPAREN          reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    COLON           reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DOUBLE_RSQUAREBR reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    TO              reduce using rule 51 (expr_list -> LSQUAREBR clist RSQUAREBR .)


state 134

    (39) clist -> expr COMMA . clist
    (37) clist -> . empty
    (38) clist -> . expr
    (39) clist -> . expr COMMA clist
    (5) empty -> .
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    RSQUAREBR       reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 103
    clist                          shift and go to state 146
    empty                          shift and go to state 102
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 135

    (26) defvar -> ID DBL_COLON type EQ . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 147
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 136

    (53) function_call -> ID LPAREN clist RPAREN .

    SEMI_COLON      reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    LSQUAREBR       reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    QUESTION_MARK   reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    PLUS            reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    MINUS           reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    TIMES           reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    DIVIDE          reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    GREATER_THAN    reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    LESS_THAN       reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    DOUBLE_EQ       reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    GREATER_THAN_EQ reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    LESS_THAN_EQ    reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    NOT_EQ          reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    AND             reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    OR              reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    FN              reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    $end            reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    COMMA           reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    RSQUAREBR       reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    RPAREN          reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    COLON           reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    DOUBLE_RSQUAREBR reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)
    TO              reduce using rule 53 (function_call -> ID LPAREN clist RPAREN .)


state 137

    (50) on_list -> expr LSQUAREBR expr RSQUAREBR .

    SEMI_COLON      reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LSQUAREBR       reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    QUESTION_MARK   reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    PLUS            reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    MINUS           reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    TIMES           reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DIVIDE          reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    GREATER_THAN    reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LESS_THAN       reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DOUBLE_EQ       reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    GREATER_THAN_EQ reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LESS_THAN_EQ    reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    NOT_EQ          reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    AND             reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    OR              reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    FN              reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    $end            reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    COMMA           reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RSQUAREBR       reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RPAREN          reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    COLON           reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DOUBLE_RSQUAREBR reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    TO              reduce using rule 50 (on_list -> expr LSQUAREBR expr RSQUAREBR .)


state 138

    (52) ternary_expr -> expr QUESTION_MARK expr COLON . expr
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 148
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 139

    (23) single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR . stmt
    (24) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR . stmt ELSE stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 149
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 140

    (78) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR . stmt ELSE stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 150
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 141

    (73) single_if -> IF LCURLYEBR error RCURLYEBR . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 151
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 142

    (19) while_loop -> WHILE LPAREN expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 152
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 143

    (74) while_loop -> WHILE LPAREN error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 153
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 144

    (20) for_loop -> FOR LPAREN ID EQ . expr TO expr RPAREN stmt
    (79) for_loop -> FOR LPAREN ID EQ . error TO expr RPAREN stmt
    (80) for_loop -> FOR LPAREN ID EQ . expr TO error RPAREN stmt
    (81) for_loop -> FOR LPAREN ID EQ . error TO error RPAREN stmt
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 155
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 154
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 145

    (21) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 156
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 146

    (39) clist -> expr COMMA clist .

    RSQUAREBR       reduce using rule 39 (clist -> expr COMMA clist .)
    RPAREN          reduce using rule 39 (clist -> expr COMMA clist .)


state 147

    (26) defvar -> ID DBL_COLON type EQ expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    SEMI_COLON      reduce using rule 26 (defvar -> ID DBL_COLON type EQ expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 148

    (52) ternary_expr -> expr QUESTION_MARK expr COLON expr .
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    FN              reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    $end            reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    COMMA           reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RSQUAREBR       reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RPAREN          reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    COLON           reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    DOUBLE_RSQUAREBR reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    TO              reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89

  ! LSQUAREBR       [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! QUESTION_MARK   [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! PLUS            [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! MINUS           [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! TIMES           [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! DIVIDE          [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! GREATER_THAN    [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! LESS_THAN       [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! NOT_EQ          [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! AND             [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! OR              [ reduce using rule 52 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]


state 149

    (23) single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .
    (24) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    NUMBER          reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    STRING          reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    IF              reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    WHILE           reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    FOR             reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    DO              reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    RETURN          reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    BEGIN           reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    LSQUAREBR       reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    NOT             reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    PLUS            reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    MINUS           reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    FN              reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    RCURLYEBR       reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    END             reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    ELSE            shift and go to state 157

  ! ELSE            [ reduce using rule 23 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .) ]


state 150

    (78) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt . ELSE stmt

    ELSE            shift and go to state 158


state 151

    (73) single_if -> IF LCURLYEBR error RCURLYEBR stmt .

    ID              reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    NUMBER          reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    STRING          reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    IF              reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    WHILE           reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    FOR             reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    DO              reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    RETURN          reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    BEGIN           reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    LSQUAREBR       reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    NOT             reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    PLUS            reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    MINUS           reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    FN              reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    RCURLYEBR       reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    END             reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    ELSE            reduce using rule 73 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)


state 152

    (19) while_loop -> WHILE LPAREN expr RPAREN stmt .

    ID              reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    DO              reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    BEGIN           reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NOT             reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FN              reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    END             reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 19 (while_loop -> WHILE LPAREN expr RPAREN stmt .)


state 153

    (74) while_loop -> WHILE LPAREN error RPAREN stmt .

    ID              reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    NUMBER          reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    STRING          reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    IF              reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    WHILE           reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    FOR             reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    DO              reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    RETURN          reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    BEGIN           reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    LSQUAREBR       reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    NOT             reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    PLUS            reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    MINUS           reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    FN              reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    RCURLYEBR       reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    END             reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    ELSE            reduce using rule 74 (while_loop -> WHILE LPAREN error RPAREN stmt .)


state 154

    (20) for_loop -> FOR LPAREN ID EQ expr . TO expr RPAREN stmt
    (80) for_loop -> FOR LPAREN ID EQ expr . TO error RPAREN stmt
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    TO              shift and go to state 159
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 155

    (79) for_loop -> FOR LPAREN ID EQ error . TO expr RPAREN stmt
    (81) for_loop -> FOR LPAREN ID EQ error . TO error RPAREN stmt

    TO              shift and go to state 160


state 156

    (21) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    DOUBLE_RSQUAREBR shift and go to state 161
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 157

    (24) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 162
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 158

    (78) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 163
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 159

    (20) for_loop -> FOR LPAREN ID EQ expr TO . expr RPAREN stmt
    (80) for_loop -> FOR LPAREN ID EQ expr TO . error RPAREN stmt
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 165
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 164
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 160

    (79) for_loop -> FOR LPAREN ID EQ error TO . expr RPAREN stmt
    (81) for_loop -> FOR LPAREN ID EQ error TO . error RPAREN stmt
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 166
    ID              shift and go to state 99
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67

    expr                           shift and go to state 167
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56

state 161

    (21) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .

    ID              reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    NUMBER          reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    STRING          reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    IF              reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    WHILE           reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    FOR             reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    DO              reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    RETURN          reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    BEGIN           reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    LSQUAREBR       reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    NOT             reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    PLUS            reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    MINUS           reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    FN              reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    RCURLYEBR       reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    END             reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    ELSE            reduce using rule 21 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)


state 162

    (24) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .

    ID              reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NUMBER          reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    STRING          reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    IF              reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    WHILE           reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FOR             reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    DO              reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RETURN          reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    BEGIN           reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LSQUAREBR       reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NOT             reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PLUS            reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    MINUS           reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FN              reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RCURLYEBR       reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    END             reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    ELSE            reduce using rule 24 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)


state 163

    (78) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .

    ID              reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NUMBER          reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    STRING          reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    IF              reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    WHILE           reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FOR             reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    DO              reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RETURN          reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    BEGIN           reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LSQUAREBR       reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NOT             reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PLUS            reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    MINUS           reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FN              reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RCURLYEBR       reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    END             reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    ELSE            reduce using rule 78 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)


state 164

    (20) for_loop -> FOR LPAREN ID EQ expr TO expr . RPAREN stmt
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 168
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 165

    (80) for_loop -> FOR LPAREN ID EQ expr TO error . RPAREN stmt

    RPAREN          shift and go to state 169


state 166

    (81) for_loop -> FOR LPAREN ID EQ error TO error . RPAREN stmt

    RPAREN          shift and go to state 170


state 167

    (79) for_loop -> FOR LPAREN ID EQ error TO expr . RPAREN stmt
    (50) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (52) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (54) binary_expr -> expr . PLUS expr
    (55) binary_expr -> expr . MINUS expr
    (56) binary_expr -> expr . TIMES expr
    (57) binary_expr -> expr . DIVIDE expr
    (58) binary_expr -> expr . GREATER_THAN expr
    (59) binary_expr -> expr . LESS_THAN expr
    (60) binary_expr -> expr . DOUBLE_EQ expr
    (61) binary_expr -> expr . GREATER_THAN_EQ expr
    (62) binary_expr -> expr . LESS_THAN_EQ expr
    (63) binary_expr -> expr . NOT_EQ expr
    (64) binary_expr -> expr . AND expr
    (65) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 171
    LSQUAREBR       shift and go to state 76
    QUESTION_MARK   shift and go to state 77
    PLUS            shift and go to state 78
    MINUS           shift and go to state 79
    TIMES           shift and go to state 80
    DIVIDE          shift and go to state 81
    GREATER_THAN    shift and go to state 82
    LESS_THAN       shift and go to state 83
    DOUBLE_EQ       shift and go to state 84
    GREATER_THAN_EQ shift and go to state 85
    LESS_THAN_EQ    shift and go to state 86
    NOT_EQ          shift and go to state 87
    AND             shift and go to state 88
    OR              shift and go to state 89


state 168

    (20) for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 172
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 169

    (80) for_loop -> FOR LPAREN ID EQ expr TO error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 173
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 170

    (81) for_loop -> FOR LPAREN ID EQ error TO error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    stmt                           shift and go to state 174
    expr                           shift and go to state 41
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 171

    (79) for_loop -> FOR LPAREN ID EQ error TO expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (40) expr -> . on_list
    (41) expr -> . expr_list
    (42) expr -> . ternary_expr
    (43) expr -> . binary_expr
    (44) expr -> . ID
    (45) expr -> . assignment
    (46) expr -> . function_call
    (47) expr -> . NUMBER
    (48) expr -> . STRING
    (25) defvar -> . ID DBL_COLON type
    (26) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (23) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (73) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (24) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (78) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (19) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (74) while_loop -> . WHILE LPAREN error RPAREN stmt
    (20) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (79) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (80) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (81) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (21) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (18) return_is -> . RETURN expr
    (22) block -> . BEGIN body END
    (50) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (51) expr_list -> . LSQUAREBR clist RSQUAREBR
    (52) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (54) binary_expr -> . expr PLUS expr
    (55) binary_expr -> . expr MINUS expr
    (56) binary_expr -> . expr TIMES expr
    (57) binary_expr -> . expr DIVIDE expr
    (58) binary_expr -> . expr GREATER_THAN expr
    (59) binary_expr -> . expr LESS_THAN expr
    (60) binary_expr -> . expr DOUBLE_EQ expr
    (61) binary_expr -> . expr GREATER_THAN_EQ expr
    (62) binary_expr -> . expr LESS_THAN_EQ expr
    (63) binary_expr -> . expr NOT_EQ expr
    (64) binary_expr -> . expr AND expr
    (65) binary_expr -> . expr OR expr
    (66) binary_expr -> . NOT expr
    (67) binary_expr -> . PLUS expr
    (68) binary_expr -> . MINUS expr
    (49) assignment -> . ID EQ expr
    (53) function_call -> . ID LPAREN clist RPAREN
    (32) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (33) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 37
    NUMBER          shift and go to state 57
    STRING          shift and go to state 58
    IF              shift and go to state 59
    WHILE           shift and go to state 60
    FOR             shift and go to state 61
    DO              shift and go to state 62
    RETURN          shift and go to state 63
    BEGIN           shift and go to state 64
    LSQUAREBR       shift and go to state 65
    NOT             shift and go to state 68
    PLUS            shift and go to state 66
    MINUS           shift and go to state 67
    FN              shift and go to state 6

    expr                           shift and go to state 41
    stmt                           shift and go to state 175
    defvar                         shift and go to state 42
    func                           shift and go to state 43
    single_if                      shift and go to state 44
    else_if                        shift and go to state 45
    while_loop                     shift and go to state 46
    for_loop                       shift and go to state 47
    do_while                       shift and go to state 48
    return_is                      shift and go to state 49
    block                          shift and go to state 50
    on_list                        shift and go to state 51
    expr_list                      shift and go to state 52
    ternary_expr                   shift and go to state 53
    binary_expr                    shift and go to state 54
    assignment                     shift and go to state 55
    function_call                  shift and go to state 56
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 172

    (20) for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .

    ID              reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    NUMBER          reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    STRING          reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    IF              reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    WHILE           reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    FOR             reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    DO              reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    RETURN          reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    BEGIN           reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    NOT             reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    PLUS            reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    MINUS           reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    FN              reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    END             reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    ELSE            reduce using rule 20 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)


state 173

    (80) for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .

    ID              reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    NUMBER          reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    STRING          reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    IF              reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    WHILE           reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    FOR             reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    DO              reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    RETURN          reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    BEGIN           reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    LSQUAREBR       reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    NOT             reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    PLUS            reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    MINUS           reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    FN              reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    RCURLYEBR       reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    END             reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    ELSE            reduce using rule 80 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)


state 174

    (81) for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .

    ID              reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    NUMBER          reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    STRING          reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    IF              reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    WHILE           reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    FOR             reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    DO              reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    RETURN          reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    BEGIN           reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    LSQUAREBR       reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    NOT             reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    PLUS            reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    MINUS           reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    FN              reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    RCURLYEBR       reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    END             reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    ELSE            reduce using rule 81 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)


state 175

    (79) for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .

    ID              reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    NUMBER          reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    STRING          reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    IF              reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    WHILE           reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    FOR             reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    DO              reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    RETURN          reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    BEGIN           reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    NOT             reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    PLUS            reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    MINUS           reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    FN              reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    END             reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    ELSE            reduce using rule 79 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for LSQUAREBR in state 104 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 104 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 104 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 104 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 104 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 104 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 104 resolved as shift
WARNING: shift/reduce conflict for AND in state 104 resolved as shift
WARNING: shift/reduce conflict for OR in state 104 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 105 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 105 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 105 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 105 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 105 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 105 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 105 resolved as shift
WARNING: shift/reduce conflict for AND in state 105 resolved as shift
WARNING: shift/reduce conflict for OR in state 105 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 106 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 106 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 106 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 106 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 106 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 106 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 106 resolved as shift
WARNING: shift/reduce conflict for AND in state 106 resolved as shift
WARNING: shift/reduce conflict for OR in state 106 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 109 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 109 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 109 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 109 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 109 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 109 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 109 resolved as shift
WARNING: shift/reduce conflict for AND in state 109 resolved as shift
WARNING: shift/reduce conflict for OR in state 109 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 113 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 113 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 113 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 113 resolved as shift
WARNING: shift/reduce conflict for AND in state 113 resolved as shift
WARNING: shift/reduce conflict for OR in state 113 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 114 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 114 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 114 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 114 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 114 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 114 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 114 resolved as shift
WARNING: shift/reduce conflict for AND in state 114 resolved as shift
WARNING: shift/reduce conflict for OR in state 114 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 115 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 115 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 115 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 115 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 115 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 115 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 115 resolved as shift
WARNING: shift/reduce conflict for AND in state 115 resolved as shift
WARNING: shift/reduce conflict for OR in state 115 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 116 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 116 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 116 resolved as shift
WARNING: shift/reduce conflict for AND in state 116 resolved as shift
WARNING: shift/reduce conflict for OR in state 116 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 117 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 117 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 117 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 117 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 117 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 117 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 117 resolved as shift
WARNING: shift/reduce conflict for AND in state 117 resolved as shift
WARNING: shift/reduce conflict for OR in state 117 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 118 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 118 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 118 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 118 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 118 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 118 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 118 resolved as shift
WARNING: shift/reduce conflict for AND in state 118 resolved as shift
WARNING: shift/reduce conflict for OR in state 118 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 119 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 119 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 119 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 119 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 119 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 119 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 119 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 119 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 119 resolved as shift
WARNING: shift/reduce conflict for AND in state 119 resolved as shift
WARNING: shift/reduce conflict for OR in state 119 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 120 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 120 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 120 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 120 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 120 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 120 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 120 resolved as shift
WARNING: shift/reduce conflict for AND in state 120 resolved as shift
WARNING: shift/reduce conflict for OR in state 120 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 121 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 121 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 121 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 121 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 121 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 121 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 121 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 121 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 121 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 121 resolved as shift
WARNING: shift/reduce conflict for AND in state 121 resolved as shift
WARNING: shift/reduce conflict for OR in state 121 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 122 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 122 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 122 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 122 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for AND in state 122 resolved as shift
WARNING: shift/reduce conflict for OR in state 122 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 123 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 123 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 123 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 123 resolved as shift
WARNING: shift/reduce conflict for OR in state 123 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 124 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 124 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 124 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 124 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 124 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 124 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 124 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 148 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 148 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 148 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 148 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 148 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 148 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 148 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 148 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 148 resolved as shift
WARNING: shift/reduce conflict for AND in state 148 resolved as shift
WARNING: shift/reduce conflict for OR in state 148 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 149 resolved as shift
