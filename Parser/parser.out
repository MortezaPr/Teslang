Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELSEIF
    FALSE
    LIST
    TRUE

Grammar

Rule 0     S' -> prog
Rule 1     prog -> empty
Rule 2     prog -> func prog
Rule 3     func -> func1
Rule 4     func -> func2
Rule 5     empty -> <empty>
Rule 6     stmt -> expr SEMI_COLON
Rule 7     stmt -> defvar SEMI_COLON
Rule 8     stmt -> func SEMI_COLON
Rule 9     stmt -> single_if
Rule 10    stmt -> else_if
Rule 11    stmt -> while_loop
Rule 12    stmt -> for_loop
Rule 13    stmt -> do_while
Rule 14    stmt -> return_is SEMI_COLON
Rule 15    stmt -> block
Rule 16    stmt -> builtin_methods SEMI_COLON
Rule 17    stmt -> function_call SEMI_COLON
Rule 18    stmt -> func1
Rule 19    stmt -> func2
Rule 20    body -> empty
Rule 21    body -> stmt body
Rule 22    return_is -> RETURN expr
Rule 23    return_is -> RETURN
Rule 24    while_loop -> WHILE LPAREN expr RPAREN stmt
Rule 25    for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt
Rule 26    do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
Rule 27    block -> BEGIN body END
Rule 28    single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
Rule 29    else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
Rule 30    defvar -> ID DBL_COLON type
Rule 31    defvar -> ID DBL_COLON type EQ expr
Rule 32    type -> INT
Rule 33    type -> STRING
Rule 34    type -> VECTOR
Rule 35    type -> NULL
Rule 36    type -> BOOLEAN
Rule 37    func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
Rule 38    func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
Rule 39    flist -> empty
Rule 40    flist -> ID AS type
Rule 41    flist -> ID AS type COMMA flist
Rule 42    clist -> empty
Rule 43    clist -> expr
Rule 44    clist -> expr COMMA clist
Rule 45    expr -> on_list
Rule 46    expr -> expr_list
Rule 47    expr -> ternary_expr
Rule 48    expr -> binary_expr
Rule 49    expr -> single_expr
Rule 50    expr -> ID
Rule 51    expr -> assignment
Rule 52    expr -> function_call
Rule 53    expr -> NUMBER
Rule 54    expr -> STRING
Rule 55    expr -> NULL
Rule 56    expr -> LPAREN expr RPAREN
Rule 57    assignment -> ID EQ expr
Rule 58    on_list -> expr LSQUAREBR expr RSQUAREBR
Rule 59    expr_list -> LSQUAREBR clist RSQUAREBR
Rule 60    ternary_expr -> expr QUESTION_MARK expr COLON expr
Rule 61    function_call -> ID LPAREN clist RPAREN
Rule 62    binary_expr -> expr PLUS expr
Rule 63    binary_expr -> expr MINUS expr
Rule 64    binary_expr -> expr TIMES expr
Rule 65    binary_expr -> expr DIVIDE expr
Rule 66    binary_expr -> expr GREATER_THAN expr
Rule 67    binary_expr -> expr LESS_THAN expr
Rule 68    binary_expr -> expr DOUBLE_EQ expr
Rule 69    binary_expr -> expr GREATER_THAN_EQ expr
Rule 70    binary_expr -> expr LESS_THAN_EQ expr
Rule 71    binary_expr -> expr NOT_EQ expr
Rule 72    binary_expr -> expr AND expr
Rule 73    binary_expr -> expr OR expr
Rule 74    single_expr -> NOT expr
Rule 75    single_expr -> PLUS expr
Rule 76    single_expr -> MINUS expr
Rule 77    builtin_methods -> SCAN LPAREN RPAREN
Rule 78    builtin_methods -> PRINT LPAREN clist RPAREN
Rule 79    builtin_methods -> LENGTH LPAREN clist RPAREN
Rule 80    builtin_methods -> EXIT LPAREN clist RPAREN
Rule 81    single_if -> IF LCURLYEBR error RCURLYEBR stmt
Rule 82    while_loop -> WHILE LPAREN error RPAREN stmt
Rule 83    func1_rtype -> FN ID LPAREN flist RPAREN LESS_THAN error GREATER_THAN LCURLYEBR body RCURLYEBR
Rule 84    func2_rtype -> FN ID LPAREN flist RPAREN LESS_THAN error GREATER_THAN EQ GREATER_THAN return_is
Rule 85    func_flist -> FN ID LPAREN error RPAREN LCURLYEBR body RCURLYEBR
Rule 86    else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
Rule 87    for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt
Rule 88    for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt
Rule 89    for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt
Rule 90    defvar_type -> ID DBL_COLON error
Rule 91    defvar_type -> ID DBL_COLON error EQ expr
Rule 92    flist -> ID AS error
Rule 93    flist -> ID AS error COMMA flist
Rule 94    flist -> error AS type
Rule 95    flist -> error AS type COMMA flist
Rule 96    flist -> ID AS type COMMA error

Terminals, with rules where they appear

AND                  : 72
AS                   : 40 41 92 93 94 95 96
BEGIN                : 27
BOOLEAN              : 36
COLON                : 60
COMMA                : 41 44 93 95 96
DBL_COLON            : 30 31 90 91
DIVIDE               : 65
DO                   : 26
DOUBLE_EQ            : 68
DOUBLE_LSQUAREBR     : 26 28 29 86
DOUBLE_RSQUAREBR     : 26 28 29 86
ELSE                 : 29 86
ELSEIF               : 
END                  : 27
EQ                   : 25 31 38 57 84 87 88 89 91
EXIT                 : 80
FALSE                : 
FN                   : 37 38 83 84 85
FOR                  : 25 87 88 89
GREATER_THAN         : 37 38 38 66 83 84 84
GREATER_THAN_EQ      : 69
ID                   : 25 30 31 37 38 40 41 50 57 61 83 84 85 87 88 89 90 91 92 93 96
IF                   : 28 29 81 86
INT                  : 32
LCURLYEBR            : 37 81 83 85
LENGTH               : 79
LESS_THAN            : 37 38 67 83 84
LESS_THAN_EQ         : 70
LIST                 : 
LPAREN               : 24 25 37 38 56 61 77 78 79 80 82 83 84 85 87 88 89
LSQUAREBR            : 58 59
MINUS                : 63 76
NOT                  : 74
NOT_EQ               : 71
NULL                 : 35 55
NUMBER               : 53
OR                   : 73
PLUS                 : 62 75
PRINT                : 78
QUESTION_MARK        : 60
RCURLYEBR            : 37 81 83 85
RETURN               : 22 23
RPAREN               : 24 25 37 38 56 61 77 78 79 80 82 83 84 85 87 88 89
RSQUAREBR            : 58 59
SCAN                 : 77
SEMI_COLON           : 6 7 8 14 16 17
STRING               : 33 54
TIMES                : 64
TO                   : 25 87 88 89
TRUE                 : 
VECTOR               : 34
WHILE                : 24 26 82
error                : 81 82 83 84 85 86 87 88 89 89 90 91 92 93 94 95 96

Nonterminals, with rules where they appear

assignment           : 51
binary_expr          : 48
block                : 15
body                 : 21 27 37 83 85
builtin_methods      : 16
clist                : 44 59 61 78 79 80
defvar               : 7
defvar_type          : 
do_while             : 13
else_if              : 10
empty                : 1 20 39 42
expr                 : 6 22 24 25 25 26 28 29 31 43 44 56 57 58 58 60 60 60 62 62 63 63 64 64 65 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 75 76 87 88 91
expr_list            : 46
flist                : 37 38 41 83 84 93 95
for_loop             : 12
func                 : 2 8
func1                : 3 18
func1_rtype          : 
func2                : 4 19
func2_rtype          : 
func_flist           : 
function_call        : 17 52
on_list              : 45
prog                 : 2 0
return_is            : 14 38 84
single_expr          : 49
single_if            : 9
stmt                 : 21 24 25 26 28 29 29 81 82 86 86 87 88 89
ternary_expr         : 47
type                 : 30 31 37 38 40 41 94 95 96
while_loop           : 11

Parsing method: LALR

state 0

    (0) S' -> . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (5) empty -> .
    (3) func -> . func1
    (4) func -> . func2
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    $end            reduce using rule 5 (empty -> .)
    FN              shift and go to state 6

    prog                           shift and go to state 1
    empty                          shift and go to state 2
    func                           shift and go to state 3
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 1

    (0) S' -> prog .



state 2

    (1) prog -> empty .

    $end            reduce using rule 1 (prog -> empty .)


state 3

    (2) prog -> func . prog
    (1) prog -> . empty
    (2) prog -> . func prog
    (5) empty -> .
    (3) func -> . func1
    (4) func -> . func2
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    $end            reduce using rule 5 (empty -> .)
    FN              shift and go to state 6

    func                           shift and go to state 3
    prog                           shift and go to state 7
    empty                          shift and go to state 2
    func1                          shift and go to state 4
    func2                          shift and go to state 5

state 4

    (3) func -> func1 .

    FN              reduce using rule 3 (func -> func1 .)
    $end            reduce using rule 3 (func -> func1 .)


state 5

    (4) func -> func2 .

    FN              reduce using rule 4 (func -> func2 .)
    $end            reduce using rule 4 (func -> func2 .)


state 6

    (37) func1 -> FN . ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN . ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    ID              shift and go to state 8


state 7

    (2) prog -> func prog .

    $end            reduce using rule 2 (prog -> func prog .)


state 8

    (37) func1 -> FN ID . LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID . LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    LPAREN          shift and go to state 9


state 9

    (37) func1 -> FN ID LPAREN . flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN . flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (39) flist -> . empty
    (40) flist -> . ID AS type
    (41) flist -> . ID AS type COMMA flist
    (92) flist -> . ID AS error
    (93) flist -> . ID AS error COMMA flist
    (94) flist -> . error AS type
    (95) flist -> . error AS type COMMA flist
    (96) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 11
    empty                          shift and go to state 12

state 10

    (40) flist -> ID . AS type
    (41) flist -> ID . AS type COMMA flist
    (92) flist -> ID . AS error
    (93) flist -> ID . AS error COMMA flist
    (96) flist -> ID . AS type COMMA error

    AS              shift and go to state 14


state 11

    (37) func1 -> FN ID LPAREN flist . RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN flist . RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    RPAREN          shift and go to state 15


state 12

    (39) flist -> empty .

    RPAREN          reduce using rule 39 (flist -> empty .)


state 13

    (94) flist -> error . AS type
    (95) flist -> error . AS type COMMA flist

    AS              shift and go to state 16


state 14

    (40) flist -> ID AS . type
    (41) flist -> ID AS . type COMMA flist
    (92) flist -> ID AS . error
    (93) flist -> ID AS . error COMMA flist
    (96) flist -> ID AS . type COMMA error
    (32) type -> . INT
    (33) type -> . STRING
    (34) type -> . VECTOR
    (35) type -> . NULL
    (36) type -> . BOOLEAN

    error           shift and go to state 18
    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 17

state 15

    (37) func1 -> FN ID LPAREN flist RPAREN . LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN flist RPAREN . LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is

    LESS_THAN       shift and go to state 24


state 16

    (94) flist -> error AS . type
    (95) flist -> error AS . type COMMA flist
    (32) type -> . INT
    (33) type -> . STRING
    (34) type -> . VECTOR
    (35) type -> . NULL
    (36) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 25

state 17

    (40) flist -> ID AS type .
    (41) flist -> ID AS type . COMMA flist
    (96) flist -> ID AS type . COMMA error

    RPAREN          reduce using rule 40 (flist -> ID AS type .)
    COMMA           shift and go to state 26


state 18

    (92) flist -> ID AS error .
    (93) flist -> ID AS error . COMMA flist

    RPAREN          reduce using rule 92 (flist -> ID AS error .)
    COMMA           shift and go to state 27


state 19

    (32) type -> INT .

    COMMA           reduce using rule 32 (type -> INT .)
    RPAREN          reduce using rule 32 (type -> INT .)
    GREATER_THAN    reduce using rule 32 (type -> INT .)
    EQ              reduce using rule 32 (type -> INT .)
    SEMI_COLON      reduce using rule 32 (type -> INT .)


state 20

    (33) type -> STRING .

    COMMA           reduce using rule 33 (type -> STRING .)
    RPAREN          reduce using rule 33 (type -> STRING .)
    GREATER_THAN    reduce using rule 33 (type -> STRING .)
    EQ              reduce using rule 33 (type -> STRING .)
    SEMI_COLON      reduce using rule 33 (type -> STRING .)


state 21

    (34) type -> VECTOR .

    COMMA           reduce using rule 34 (type -> VECTOR .)
    RPAREN          reduce using rule 34 (type -> VECTOR .)
    GREATER_THAN    reduce using rule 34 (type -> VECTOR .)
    EQ              reduce using rule 34 (type -> VECTOR .)
    SEMI_COLON      reduce using rule 34 (type -> VECTOR .)


state 22

    (35) type -> NULL .

    COMMA           reduce using rule 35 (type -> NULL .)
    RPAREN          reduce using rule 35 (type -> NULL .)
    GREATER_THAN    reduce using rule 35 (type -> NULL .)
    EQ              reduce using rule 35 (type -> NULL .)
    SEMI_COLON      reduce using rule 35 (type -> NULL .)


state 23

    (36) type -> BOOLEAN .

    COMMA           reduce using rule 36 (type -> BOOLEAN .)
    RPAREN          reduce using rule 36 (type -> BOOLEAN .)
    GREATER_THAN    reduce using rule 36 (type -> BOOLEAN .)
    EQ              reduce using rule 36 (type -> BOOLEAN .)
    SEMI_COLON      reduce using rule 36 (type -> BOOLEAN .)


state 24

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN . type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN . type GREATER_THAN EQ GREATER_THAN return_is
    (32) type -> . INT
    (33) type -> . STRING
    (34) type -> . VECTOR
    (35) type -> . NULL
    (36) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 28

state 25

    (94) flist -> error AS type .
    (95) flist -> error AS type . COMMA flist

    RPAREN          reduce using rule 94 (flist -> error AS type .)
    COMMA           shift and go to state 29


state 26

    (41) flist -> ID AS type COMMA . flist
    (96) flist -> ID AS type COMMA . error
    (39) flist -> . empty
    (40) flist -> . ID AS type
    (41) flist -> . ID AS type COMMA flist
    (92) flist -> . ID AS error
    (93) flist -> . ID AS error COMMA flist
    (94) flist -> . error AS type
    (95) flist -> . error AS type COMMA flist
    (96) flist -> . ID AS type COMMA error
    (5) empty -> .

    error           shift and go to state 31
    ID              shift and go to state 10
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 30
    empty                          shift and go to state 12

state 27

    (93) flist -> ID AS error COMMA . flist
    (39) flist -> . empty
    (40) flist -> . ID AS type
    (41) flist -> . ID AS type COMMA flist
    (92) flist -> . ID AS error
    (93) flist -> . ID AS error COMMA flist
    (94) flist -> . error AS type
    (95) flist -> . error AS type COMMA flist
    (96) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 32
    empty                          shift and go to state 12

state 28

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type . GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type . GREATER_THAN EQ GREATER_THAN return_is

    GREATER_THAN    shift and go to state 33


state 29

    (95) flist -> error AS type COMMA . flist
    (39) flist -> . empty
    (40) flist -> . ID AS type
    (41) flist -> . ID AS type COMMA flist
    (92) flist -> . ID AS error
    (93) flist -> . ID AS error COMMA flist
    (94) flist -> . error AS type
    (95) flist -> . error AS type COMMA flist
    (96) flist -> . ID AS type COMMA error
    (5) empty -> .

    ID              shift and go to state 10
    error           shift and go to state 13
    RPAREN          reduce using rule 5 (empty -> .)

    flist                          shift and go to state 34
    empty                          shift and go to state 12

state 30

    (41) flist -> ID AS type COMMA flist .

    RPAREN          reduce using rule 41 (flist -> ID AS type COMMA flist .)


state 31

    (96) flist -> ID AS type COMMA error .
    (94) flist -> error . AS type
    (95) flist -> error . AS type COMMA flist

    RPAREN          reduce using rule 96 (flist -> ID AS type COMMA error .)
    AS              shift and go to state 16


state 32

    (93) flist -> ID AS error COMMA flist .

    RPAREN          reduce using rule 93 (flist -> ID AS error COMMA flist .)


state 33

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN . LCURLYEBR body RCURLYEBR
    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN . EQ GREATER_THAN return_is

    LCURLYEBR       shift and go to state 35
    EQ              shift and go to state 36


state 34

    (95) flist -> error AS type COMMA flist .

    RPAREN          reduce using rule 95 (flist -> error AS type COMMA flist .)


state 35

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR . body RCURLYEBR
    (20) body -> . empty
    (21) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    RCURLYEBR       reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    body                           shift and go to state 39
    empty                          shift and go to state 40
    stmt                           shift and go to state 41
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 36

    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ . GREATER_THAN return_is

    GREATER_THAN    shift and go to state 79


state 37

    (50) expr -> ID .
    (30) defvar -> ID . DBL_COLON type
    (31) defvar -> ID . DBL_COLON type EQ expr
    (61) function_call -> ID . LPAREN clist RPAREN
    (57) assignment -> ID . EQ expr

    SEMI_COLON      reduce using rule 50 (expr -> ID .)
    LSQUAREBR       reduce using rule 50 (expr -> ID .)
    QUESTION_MARK   reduce using rule 50 (expr -> ID .)
    PLUS            reduce using rule 50 (expr -> ID .)
    MINUS           reduce using rule 50 (expr -> ID .)
    TIMES           reduce using rule 50 (expr -> ID .)
    DIVIDE          reduce using rule 50 (expr -> ID .)
    GREATER_THAN    reduce using rule 50 (expr -> ID .)
    LESS_THAN       reduce using rule 50 (expr -> ID .)
    DOUBLE_EQ       reduce using rule 50 (expr -> ID .)
    GREATER_THAN_EQ reduce using rule 50 (expr -> ID .)
    LESS_THAN_EQ    reduce using rule 50 (expr -> ID .)
    NOT_EQ          reduce using rule 50 (expr -> ID .)
    AND             reduce using rule 50 (expr -> ID .)
    OR              reduce using rule 50 (expr -> ID .)
    DBL_COLON       shift and go to state 80
    LPAREN          shift and go to state 82
    EQ              shift and go to state 81


state 38

    (56) expr -> LPAREN . expr RPAREN
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 83
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 39

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body . RCURLYEBR

    RCURLYEBR       shift and go to state 86


state 40

    (20) body -> empty .

    RCURLYEBR       reduce using rule 20 (body -> empty .)
    END             reduce using rule 20 (body -> empty .)


state 41

    (21) body -> stmt . body
    (20) body -> . empty
    (21) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    RCURLYEBR       reduce using rule 5 (empty -> .)
    END             reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 41
    body                           shift and go to state 87
    empty                          shift and go to state 40
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 42

    (6) stmt -> expr . SEMI_COLON
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    SEMI_COLON      shift and go to state 88
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 43

    (7) stmt -> defvar . SEMI_COLON

    SEMI_COLON      shift and go to state 103


state 44

    (8) stmt -> func . SEMI_COLON

    SEMI_COLON      shift and go to state 104


state 45

    (9) stmt -> single_if .

    ID              reduce using rule 9 (stmt -> single_if .)
    NUMBER          reduce using rule 9 (stmt -> single_if .)
    STRING          reduce using rule 9 (stmt -> single_if .)
    NULL            reduce using rule 9 (stmt -> single_if .)
    LPAREN          reduce using rule 9 (stmt -> single_if .)
    IF              reduce using rule 9 (stmt -> single_if .)
    WHILE           reduce using rule 9 (stmt -> single_if .)
    FOR             reduce using rule 9 (stmt -> single_if .)
    DO              reduce using rule 9 (stmt -> single_if .)
    RETURN          reduce using rule 9 (stmt -> single_if .)
    BEGIN           reduce using rule 9 (stmt -> single_if .)
    SCAN            reduce using rule 9 (stmt -> single_if .)
    PRINT           reduce using rule 9 (stmt -> single_if .)
    LENGTH          reduce using rule 9 (stmt -> single_if .)
    EXIT            reduce using rule 9 (stmt -> single_if .)
    FN              reduce using rule 9 (stmt -> single_if .)
    LSQUAREBR       reduce using rule 9 (stmt -> single_if .)
    NOT             reduce using rule 9 (stmt -> single_if .)
    PLUS            reduce using rule 9 (stmt -> single_if .)
    MINUS           reduce using rule 9 (stmt -> single_if .)
    RCURLYEBR       reduce using rule 9 (stmt -> single_if .)
    END             reduce using rule 9 (stmt -> single_if .)
    ELSE            reduce using rule 9 (stmt -> single_if .)


state 46

    (10) stmt -> else_if .

    ID              reduce using rule 10 (stmt -> else_if .)
    NUMBER          reduce using rule 10 (stmt -> else_if .)
    STRING          reduce using rule 10 (stmt -> else_if .)
    NULL            reduce using rule 10 (stmt -> else_if .)
    LPAREN          reduce using rule 10 (stmt -> else_if .)
    IF              reduce using rule 10 (stmt -> else_if .)
    WHILE           reduce using rule 10 (stmt -> else_if .)
    FOR             reduce using rule 10 (stmt -> else_if .)
    DO              reduce using rule 10 (stmt -> else_if .)
    RETURN          reduce using rule 10 (stmt -> else_if .)
    BEGIN           reduce using rule 10 (stmt -> else_if .)
    SCAN            reduce using rule 10 (stmt -> else_if .)
    PRINT           reduce using rule 10 (stmt -> else_if .)
    LENGTH          reduce using rule 10 (stmt -> else_if .)
    EXIT            reduce using rule 10 (stmt -> else_if .)
    FN              reduce using rule 10 (stmt -> else_if .)
    LSQUAREBR       reduce using rule 10 (stmt -> else_if .)
    NOT             reduce using rule 10 (stmt -> else_if .)
    PLUS            reduce using rule 10 (stmt -> else_if .)
    MINUS           reduce using rule 10 (stmt -> else_if .)
    RCURLYEBR       reduce using rule 10 (stmt -> else_if .)
    END             reduce using rule 10 (stmt -> else_if .)
    ELSE            reduce using rule 10 (stmt -> else_if .)


state 47

    (11) stmt -> while_loop .

    ID              reduce using rule 11 (stmt -> while_loop .)
    NUMBER          reduce using rule 11 (stmt -> while_loop .)
    STRING          reduce using rule 11 (stmt -> while_loop .)
    NULL            reduce using rule 11 (stmt -> while_loop .)
    LPAREN          reduce using rule 11 (stmt -> while_loop .)
    IF              reduce using rule 11 (stmt -> while_loop .)
    WHILE           reduce using rule 11 (stmt -> while_loop .)
    FOR             reduce using rule 11 (stmt -> while_loop .)
    DO              reduce using rule 11 (stmt -> while_loop .)
    RETURN          reduce using rule 11 (stmt -> while_loop .)
    BEGIN           reduce using rule 11 (stmt -> while_loop .)
    SCAN            reduce using rule 11 (stmt -> while_loop .)
    PRINT           reduce using rule 11 (stmt -> while_loop .)
    LENGTH          reduce using rule 11 (stmt -> while_loop .)
    EXIT            reduce using rule 11 (stmt -> while_loop .)
    FN              reduce using rule 11 (stmt -> while_loop .)
    LSQUAREBR       reduce using rule 11 (stmt -> while_loop .)
    NOT             reduce using rule 11 (stmt -> while_loop .)
    PLUS            reduce using rule 11 (stmt -> while_loop .)
    MINUS           reduce using rule 11 (stmt -> while_loop .)
    RCURLYEBR       reduce using rule 11 (stmt -> while_loop .)
    END             reduce using rule 11 (stmt -> while_loop .)
    ELSE            reduce using rule 11 (stmt -> while_loop .)


state 48

    (12) stmt -> for_loop .

    ID              reduce using rule 12 (stmt -> for_loop .)
    NUMBER          reduce using rule 12 (stmt -> for_loop .)
    STRING          reduce using rule 12 (stmt -> for_loop .)
    NULL            reduce using rule 12 (stmt -> for_loop .)
    LPAREN          reduce using rule 12 (stmt -> for_loop .)
    IF              reduce using rule 12 (stmt -> for_loop .)
    WHILE           reduce using rule 12 (stmt -> for_loop .)
    FOR             reduce using rule 12 (stmt -> for_loop .)
    DO              reduce using rule 12 (stmt -> for_loop .)
    RETURN          reduce using rule 12 (stmt -> for_loop .)
    BEGIN           reduce using rule 12 (stmt -> for_loop .)
    SCAN            reduce using rule 12 (stmt -> for_loop .)
    PRINT           reduce using rule 12 (stmt -> for_loop .)
    LENGTH          reduce using rule 12 (stmt -> for_loop .)
    EXIT            reduce using rule 12 (stmt -> for_loop .)
    FN              reduce using rule 12 (stmt -> for_loop .)
    LSQUAREBR       reduce using rule 12 (stmt -> for_loop .)
    NOT             reduce using rule 12 (stmt -> for_loop .)
    PLUS            reduce using rule 12 (stmt -> for_loop .)
    MINUS           reduce using rule 12 (stmt -> for_loop .)
    RCURLYEBR       reduce using rule 12 (stmt -> for_loop .)
    END             reduce using rule 12 (stmt -> for_loop .)
    ELSE            reduce using rule 12 (stmt -> for_loop .)


state 49

    (13) stmt -> do_while .

    ID              reduce using rule 13 (stmt -> do_while .)
    NUMBER          reduce using rule 13 (stmt -> do_while .)
    STRING          reduce using rule 13 (stmt -> do_while .)
    NULL            reduce using rule 13 (stmt -> do_while .)
    LPAREN          reduce using rule 13 (stmt -> do_while .)
    IF              reduce using rule 13 (stmt -> do_while .)
    WHILE           reduce using rule 13 (stmt -> do_while .)
    FOR             reduce using rule 13 (stmt -> do_while .)
    DO              reduce using rule 13 (stmt -> do_while .)
    RETURN          reduce using rule 13 (stmt -> do_while .)
    BEGIN           reduce using rule 13 (stmt -> do_while .)
    SCAN            reduce using rule 13 (stmt -> do_while .)
    PRINT           reduce using rule 13 (stmt -> do_while .)
    LENGTH          reduce using rule 13 (stmt -> do_while .)
    EXIT            reduce using rule 13 (stmt -> do_while .)
    FN              reduce using rule 13 (stmt -> do_while .)
    LSQUAREBR       reduce using rule 13 (stmt -> do_while .)
    NOT             reduce using rule 13 (stmt -> do_while .)
    PLUS            reduce using rule 13 (stmt -> do_while .)
    MINUS           reduce using rule 13 (stmt -> do_while .)
    RCURLYEBR       reduce using rule 13 (stmt -> do_while .)
    END             reduce using rule 13 (stmt -> do_while .)
    ELSE            reduce using rule 13 (stmt -> do_while .)


state 50

    (14) stmt -> return_is . SEMI_COLON

    SEMI_COLON      shift and go to state 105


state 51

    (15) stmt -> block .

    ID              reduce using rule 15 (stmt -> block .)
    NUMBER          reduce using rule 15 (stmt -> block .)
    STRING          reduce using rule 15 (stmt -> block .)
    NULL            reduce using rule 15 (stmt -> block .)
    LPAREN          reduce using rule 15 (stmt -> block .)
    IF              reduce using rule 15 (stmt -> block .)
    WHILE           reduce using rule 15 (stmt -> block .)
    FOR             reduce using rule 15 (stmt -> block .)
    DO              reduce using rule 15 (stmt -> block .)
    RETURN          reduce using rule 15 (stmt -> block .)
    BEGIN           reduce using rule 15 (stmt -> block .)
    SCAN            reduce using rule 15 (stmt -> block .)
    PRINT           reduce using rule 15 (stmt -> block .)
    LENGTH          reduce using rule 15 (stmt -> block .)
    EXIT            reduce using rule 15 (stmt -> block .)
    FN              reduce using rule 15 (stmt -> block .)
    LSQUAREBR       reduce using rule 15 (stmt -> block .)
    NOT             reduce using rule 15 (stmt -> block .)
    PLUS            reduce using rule 15 (stmt -> block .)
    MINUS           reduce using rule 15 (stmt -> block .)
    RCURLYEBR       reduce using rule 15 (stmt -> block .)
    END             reduce using rule 15 (stmt -> block .)
    ELSE            reduce using rule 15 (stmt -> block .)


state 52

    (16) stmt -> builtin_methods . SEMI_COLON

    SEMI_COLON      shift and go to state 106


state 53

    (17) stmt -> function_call . SEMI_COLON
    (52) expr -> function_call .

  ! shift/reduce conflict for SEMI_COLON resolved as shift
    SEMI_COLON      shift and go to state 107
    LSQUAREBR       reduce using rule 52 (expr -> function_call .)
    QUESTION_MARK   reduce using rule 52 (expr -> function_call .)
    PLUS            reduce using rule 52 (expr -> function_call .)
    MINUS           reduce using rule 52 (expr -> function_call .)
    TIMES           reduce using rule 52 (expr -> function_call .)
    DIVIDE          reduce using rule 52 (expr -> function_call .)
    GREATER_THAN    reduce using rule 52 (expr -> function_call .)
    LESS_THAN       reduce using rule 52 (expr -> function_call .)
    DOUBLE_EQ       reduce using rule 52 (expr -> function_call .)
    GREATER_THAN_EQ reduce using rule 52 (expr -> function_call .)
    LESS_THAN_EQ    reduce using rule 52 (expr -> function_call .)
    NOT_EQ          reduce using rule 52 (expr -> function_call .)
    AND             reduce using rule 52 (expr -> function_call .)
    OR              reduce using rule 52 (expr -> function_call .)

  ! SEMI_COLON      [ reduce using rule 52 (expr -> function_call .) ]


state 54

    (18) stmt -> func1 .
    (3) func -> func1 .

    ID              reduce using rule 18 (stmt -> func1 .)
    NUMBER          reduce using rule 18 (stmt -> func1 .)
    STRING          reduce using rule 18 (stmt -> func1 .)
    NULL            reduce using rule 18 (stmt -> func1 .)
    LPAREN          reduce using rule 18 (stmt -> func1 .)
    IF              reduce using rule 18 (stmt -> func1 .)
    WHILE           reduce using rule 18 (stmt -> func1 .)
    FOR             reduce using rule 18 (stmt -> func1 .)
    DO              reduce using rule 18 (stmt -> func1 .)
    RETURN          reduce using rule 18 (stmt -> func1 .)
    BEGIN           reduce using rule 18 (stmt -> func1 .)
    SCAN            reduce using rule 18 (stmt -> func1 .)
    PRINT           reduce using rule 18 (stmt -> func1 .)
    LENGTH          reduce using rule 18 (stmt -> func1 .)
    EXIT            reduce using rule 18 (stmt -> func1 .)
    FN              reduce using rule 18 (stmt -> func1 .)
    LSQUAREBR       reduce using rule 18 (stmt -> func1 .)
    NOT             reduce using rule 18 (stmt -> func1 .)
    PLUS            reduce using rule 18 (stmt -> func1 .)
    MINUS           reduce using rule 18 (stmt -> func1 .)
    RCURLYEBR       reduce using rule 18 (stmt -> func1 .)
    END             reduce using rule 18 (stmt -> func1 .)
    ELSE            reduce using rule 18 (stmt -> func1 .)
    SEMI_COLON      reduce using rule 3 (func -> func1 .)


state 55

    (19) stmt -> func2 .
    (4) func -> func2 .

    ID              reduce using rule 19 (stmt -> func2 .)
    NUMBER          reduce using rule 19 (stmt -> func2 .)
    STRING          reduce using rule 19 (stmt -> func2 .)
    NULL            reduce using rule 19 (stmt -> func2 .)
    LPAREN          reduce using rule 19 (stmt -> func2 .)
    IF              reduce using rule 19 (stmt -> func2 .)
    WHILE           reduce using rule 19 (stmt -> func2 .)
    FOR             reduce using rule 19 (stmt -> func2 .)
    DO              reduce using rule 19 (stmt -> func2 .)
    RETURN          reduce using rule 19 (stmt -> func2 .)
    BEGIN           reduce using rule 19 (stmt -> func2 .)
    SCAN            reduce using rule 19 (stmt -> func2 .)
    PRINT           reduce using rule 19 (stmt -> func2 .)
    LENGTH          reduce using rule 19 (stmt -> func2 .)
    EXIT            reduce using rule 19 (stmt -> func2 .)
    FN              reduce using rule 19 (stmt -> func2 .)
    LSQUAREBR       reduce using rule 19 (stmt -> func2 .)
    NOT             reduce using rule 19 (stmt -> func2 .)
    PLUS            reduce using rule 19 (stmt -> func2 .)
    MINUS           reduce using rule 19 (stmt -> func2 .)
    RCURLYEBR       reduce using rule 19 (stmt -> func2 .)
    END             reduce using rule 19 (stmt -> func2 .)
    ELSE            reduce using rule 19 (stmt -> func2 .)
    SEMI_COLON      reduce using rule 4 (func -> func2 .)


state 56

    (45) expr -> on_list .

    SEMI_COLON      reduce using rule 45 (expr -> on_list .)
    LSQUAREBR       reduce using rule 45 (expr -> on_list .)
    QUESTION_MARK   reduce using rule 45 (expr -> on_list .)
    PLUS            reduce using rule 45 (expr -> on_list .)
    MINUS           reduce using rule 45 (expr -> on_list .)
    TIMES           reduce using rule 45 (expr -> on_list .)
    DIVIDE          reduce using rule 45 (expr -> on_list .)
    GREATER_THAN    reduce using rule 45 (expr -> on_list .)
    LESS_THAN       reduce using rule 45 (expr -> on_list .)
    DOUBLE_EQ       reduce using rule 45 (expr -> on_list .)
    GREATER_THAN_EQ reduce using rule 45 (expr -> on_list .)
    LESS_THAN_EQ    reduce using rule 45 (expr -> on_list .)
    NOT_EQ          reduce using rule 45 (expr -> on_list .)
    AND             reduce using rule 45 (expr -> on_list .)
    OR              reduce using rule 45 (expr -> on_list .)
    RPAREN          reduce using rule 45 (expr -> on_list .)
    FN              reduce using rule 45 (expr -> on_list .)
    $end            reduce using rule 45 (expr -> on_list .)
    ID              reduce using rule 45 (expr -> on_list .)
    NUMBER          reduce using rule 45 (expr -> on_list .)
    STRING          reduce using rule 45 (expr -> on_list .)
    NULL            reduce using rule 45 (expr -> on_list .)
    LPAREN          reduce using rule 45 (expr -> on_list .)
    IF              reduce using rule 45 (expr -> on_list .)
    WHILE           reduce using rule 45 (expr -> on_list .)
    FOR             reduce using rule 45 (expr -> on_list .)
    DO              reduce using rule 45 (expr -> on_list .)
    RETURN          reduce using rule 45 (expr -> on_list .)
    BEGIN           reduce using rule 45 (expr -> on_list .)
    SCAN            reduce using rule 45 (expr -> on_list .)
    PRINT           reduce using rule 45 (expr -> on_list .)
    LENGTH          reduce using rule 45 (expr -> on_list .)
    EXIT            reduce using rule 45 (expr -> on_list .)
    NOT             reduce using rule 45 (expr -> on_list .)
    RCURLYEBR       reduce using rule 45 (expr -> on_list .)
    END             reduce using rule 45 (expr -> on_list .)
    ELSE            reduce using rule 45 (expr -> on_list .)
    COMMA           reduce using rule 45 (expr -> on_list .)
    RSQUAREBR       reduce using rule 45 (expr -> on_list .)
    COLON           reduce using rule 45 (expr -> on_list .)
    DOUBLE_RSQUAREBR reduce using rule 45 (expr -> on_list .)
    TO              reduce using rule 45 (expr -> on_list .)


state 57

    (46) expr -> expr_list .

    SEMI_COLON      reduce using rule 46 (expr -> expr_list .)
    LSQUAREBR       reduce using rule 46 (expr -> expr_list .)
    QUESTION_MARK   reduce using rule 46 (expr -> expr_list .)
    PLUS            reduce using rule 46 (expr -> expr_list .)
    MINUS           reduce using rule 46 (expr -> expr_list .)
    TIMES           reduce using rule 46 (expr -> expr_list .)
    DIVIDE          reduce using rule 46 (expr -> expr_list .)
    GREATER_THAN    reduce using rule 46 (expr -> expr_list .)
    LESS_THAN       reduce using rule 46 (expr -> expr_list .)
    DOUBLE_EQ       reduce using rule 46 (expr -> expr_list .)
    GREATER_THAN_EQ reduce using rule 46 (expr -> expr_list .)
    LESS_THAN_EQ    reduce using rule 46 (expr -> expr_list .)
    NOT_EQ          reduce using rule 46 (expr -> expr_list .)
    AND             reduce using rule 46 (expr -> expr_list .)
    OR              reduce using rule 46 (expr -> expr_list .)
    RPAREN          reduce using rule 46 (expr -> expr_list .)
    FN              reduce using rule 46 (expr -> expr_list .)
    $end            reduce using rule 46 (expr -> expr_list .)
    ID              reduce using rule 46 (expr -> expr_list .)
    NUMBER          reduce using rule 46 (expr -> expr_list .)
    STRING          reduce using rule 46 (expr -> expr_list .)
    NULL            reduce using rule 46 (expr -> expr_list .)
    LPAREN          reduce using rule 46 (expr -> expr_list .)
    IF              reduce using rule 46 (expr -> expr_list .)
    WHILE           reduce using rule 46 (expr -> expr_list .)
    FOR             reduce using rule 46 (expr -> expr_list .)
    DO              reduce using rule 46 (expr -> expr_list .)
    RETURN          reduce using rule 46 (expr -> expr_list .)
    BEGIN           reduce using rule 46 (expr -> expr_list .)
    SCAN            reduce using rule 46 (expr -> expr_list .)
    PRINT           reduce using rule 46 (expr -> expr_list .)
    LENGTH          reduce using rule 46 (expr -> expr_list .)
    EXIT            reduce using rule 46 (expr -> expr_list .)
    NOT             reduce using rule 46 (expr -> expr_list .)
    RCURLYEBR       reduce using rule 46 (expr -> expr_list .)
    END             reduce using rule 46 (expr -> expr_list .)
    ELSE            reduce using rule 46 (expr -> expr_list .)
    COMMA           reduce using rule 46 (expr -> expr_list .)
    RSQUAREBR       reduce using rule 46 (expr -> expr_list .)
    COLON           reduce using rule 46 (expr -> expr_list .)
    DOUBLE_RSQUAREBR reduce using rule 46 (expr -> expr_list .)
    TO              reduce using rule 46 (expr -> expr_list .)


state 58

    (47) expr -> ternary_expr .

    SEMI_COLON      reduce using rule 47 (expr -> ternary_expr .)
    LSQUAREBR       reduce using rule 47 (expr -> ternary_expr .)
    QUESTION_MARK   reduce using rule 47 (expr -> ternary_expr .)
    PLUS            reduce using rule 47 (expr -> ternary_expr .)
    MINUS           reduce using rule 47 (expr -> ternary_expr .)
    TIMES           reduce using rule 47 (expr -> ternary_expr .)
    DIVIDE          reduce using rule 47 (expr -> ternary_expr .)
    GREATER_THAN    reduce using rule 47 (expr -> ternary_expr .)
    LESS_THAN       reduce using rule 47 (expr -> ternary_expr .)
    DOUBLE_EQ       reduce using rule 47 (expr -> ternary_expr .)
    GREATER_THAN_EQ reduce using rule 47 (expr -> ternary_expr .)
    LESS_THAN_EQ    reduce using rule 47 (expr -> ternary_expr .)
    NOT_EQ          reduce using rule 47 (expr -> ternary_expr .)
    AND             reduce using rule 47 (expr -> ternary_expr .)
    OR              reduce using rule 47 (expr -> ternary_expr .)
    RPAREN          reduce using rule 47 (expr -> ternary_expr .)
    FN              reduce using rule 47 (expr -> ternary_expr .)
    $end            reduce using rule 47 (expr -> ternary_expr .)
    ID              reduce using rule 47 (expr -> ternary_expr .)
    NUMBER          reduce using rule 47 (expr -> ternary_expr .)
    STRING          reduce using rule 47 (expr -> ternary_expr .)
    NULL            reduce using rule 47 (expr -> ternary_expr .)
    LPAREN          reduce using rule 47 (expr -> ternary_expr .)
    IF              reduce using rule 47 (expr -> ternary_expr .)
    WHILE           reduce using rule 47 (expr -> ternary_expr .)
    FOR             reduce using rule 47 (expr -> ternary_expr .)
    DO              reduce using rule 47 (expr -> ternary_expr .)
    RETURN          reduce using rule 47 (expr -> ternary_expr .)
    BEGIN           reduce using rule 47 (expr -> ternary_expr .)
    SCAN            reduce using rule 47 (expr -> ternary_expr .)
    PRINT           reduce using rule 47 (expr -> ternary_expr .)
    LENGTH          reduce using rule 47 (expr -> ternary_expr .)
    EXIT            reduce using rule 47 (expr -> ternary_expr .)
    NOT             reduce using rule 47 (expr -> ternary_expr .)
    RCURLYEBR       reduce using rule 47 (expr -> ternary_expr .)
    END             reduce using rule 47 (expr -> ternary_expr .)
    ELSE            reduce using rule 47 (expr -> ternary_expr .)
    COMMA           reduce using rule 47 (expr -> ternary_expr .)
    RSQUAREBR       reduce using rule 47 (expr -> ternary_expr .)
    COLON           reduce using rule 47 (expr -> ternary_expr .)
    DOUBLE_RSQUAREBR reduce using rule 47 (expr -> ternary_expr .)
    TO              reduce using rule 47 (expr -> ternary_expr .)


state 59

    (48) expr -> binary_expr .

    SEMI_COLON      reduce using rule 48 (expr -> binary_expr .)
    LSQUAREBR       reduce using rule 48 (expr -> binary_expr .)
    QUESTION_MARK   reduce using rule 48 (expr -> binary_expr .)
    PLUS            reduce using rule 48 (expr -> binary_expr .)
    MINUS           reduce using rule 48 (expr -> binary_expr .)
    TIMES           reduce using rule 48 (expr -> binary_expr .)
    DIVIDE          reduce using rule 48 (expr -> binary_expr .)
    GREATER_THAN    reduce using rule 48 (expr -> binary_expr .)
    LESS_THAN       reduce using rule 48 (expr -> binary_expr .)
    DOUBLE_EQ       reduce using rule 48 (expr -> binary_expr .)
    GREATER_THAN_EQ reduce using rule 48 (expr -> binary_expr .)
    LESS_THAN_EQ    reduce using rule 48 (expr -> binary_expr .)
    NOT_EQ          reduce using rule 48 (expr -> binary_expr .)
    AND             reduce using rule 48 (expr -> binary_expr .)
    OR              reduce using rule 48 (expr -> binary_expr .)
    RPAREN          reduce using rule 48 (expr -> binary_expr .)
    FN              reduce using rule 48 (expr -> binary_expr .)
    $end            reduce using rule 48 (expr -> binary_expr .)
    ID              reduce using rule 48 (expr -> binary_expr .)
    NUMBER          reduce using rule 48 (expr -> binary_expr .)
    STRING          reduce using rule 48 (expr -> binary_expr .)
    NULL            reduce using rule 48 (expr -> binary_expr .)
    LPAREN          reduce using rule 48 (expr -> binary_expr .)
    IF              reduce using rule 48 (expr -> binary_expr .)
    WHILE           reduce using rule 48 (expr -> binary_expr .)
    FOR             reduce using rule 48 (expr -> binary_expr .)
    DO              reduce using rule 48 (expr -> binary_expr .)
    RETURN          reduce using rule 48 (expr -> binary_expr .)
    BEGIN           reduce using rule 48 (expr -> binary_expr .)
    SCAN            reduce using rule 48 (expr -> binary_expr .)
    PRINT           reduce using rule 48 (expr -> binary_expr .)
    LENGTH          reduce using rule 48 (expr -> binary_expr .)
    EXIT            reduce using rule 48 (expr -> binary_expr .)
    NOT             reduce using rule 48 (expr -> binary_expr .)
    RCURLYEBR       reduce using rule 48 (expr -> binary_expr .)
    END             reduce using rule 48 (expr -> binary_expr .)
    ELSE            reduce using rule 48 (expr -> binary_expr .)
    COMMA           reduce using rule 48 (expr -> binary_expr .)
    RSQUAREBR       reduce using rule 48 (expr -> binary_expr .)
    COLON           reduce using rule 48 (expr -> binary_expr .)
    DOUBLE_RSQUAREBR reduce using rule 48 (expr -> binary_expr .)
    TO              reduce using rule 48 (expr -> binary_expr .)


state 60

    (49) expr -> single_expr .

    SEMI_COLON      reduce using rule 49 (expr -> single_expr .)
    LSQUAREBR       reduce using rule 49 (expr -> single_expr .)
    QUESTION_MARK   reduce using rule 49 (expr -> single_expr .)
    PLUS            reduce using rule 49 (expr -> single_expr .)
    MINUS           reduce using rule 49 (expr -> single_expr .)
    TIMES           reduce using rule 49 (expr -> single_expr .)
    DIVIDE          reduce using rule 49 (expr -> single_expr .)
    GREATER_THAN    reduce using rule 49 (expr -> single_expr .)
    LESS_THAN       reduce using rule 49 (expr -> single_expr .)
    DOUBLE_EQ       reduce using rule 49 (expr -> single_expr .)
    GREATER_THAN_EQ reduce using rule 49 (expr -> single_expr .)
    LESS_THAN_EQ    reduce using rule 49 (expr -> single_expr .)
    NOT_EQ          reduce using rule 49 (expr -> single_expr .)
    AND             reduce using rule 49 (expr -> single_expr .)
    OR              reduce using rule 49 (expr -> single_expr .)
    RPAREN          reduce using rule 49 (expr -> single_expr .)
    FN              reduce using rule 49 (expr -> single_expr .)
    $end            reduce using rule 49 (expr -> single_expr .)
    ID              reduce using rule 49 (expr -> single_expr .)
    NUMBER          reduce using rule 49 (expr -> single_expr .)
    STRING          reduce using rule 49 (expr -> single_expr .)
    NULL            reduce using rule 49 (expr -> single_expr .)
    LPAREN          reduce using rule 49 (expr -> single_expr .)
    IF              reduce using rule 49 (expr -> single_expr .)
    WHILE           reduce using rule 49 (expr -> single_expr .)
    FOR             reduce using rule 49 (expr -> single_expr .)
    DO              reduce using rule 49 (expr -> single_expr .)
    RETURN          reduce using rule 49 (expr -> single_expr .)
    BEGIN           reduce using rule 49 (expr -> single_expr .)
    SCAN            reduce using rule 49 (expr -> single_expr .)
    PRINT           reduce using rule 49 (expr -> single_expr .)
    LENGTH          reduce using rule 49 (expr -> single_expr .)
    EXIT            reduce using rule 49 (expr -> single_expr .)
    NOT             reduce using rule 49 (expr -> single_expr .)
    RCURLYEBR       reduce using rule 49 (expr -> single_expr .)
    END             reduce using rule 49 (expr -> single_expr .)
    ELSE            reduce using rule 49 (expr -> single_expr .)
    COMMA           reduce using rule 49 (expr -> single_expr .)
    RSQUAREBR       reduce using rule 49 (expr -> single_expr .)
    COLON           reduce using rule 49 (expr -> single_expr .)
    DOUBLE_RSQUAREBR reduce using rule 49 (expr -> single_expr .)
    TO              reduce using rule 49 (expr -> single_expr .)


state 61

    (51) expr -> assignment .

    SEMI_COLON      reduce using rule 51 (expr -> assignment .)
    LSQUAREBR       reduce using rule 51 (expr -> assignment .)
    QUESTION_MARK   reduce using rule 51 (expr -> assignment .)
    PLUS            reduce using rule 51 (expr -> assignment .)
    MINUS           reduce using rule 51 (expr -> assignment .)
    TIMES           reduce using rule 51 (expr -> assignment .)
    DIVIDE          reduce using rule 51 (expr -> assignment .)
    GREATER_THAN    reduce using rule 51 (expr -> assignment .)
    LESS_THAN       reduce using rule 51 (expr -> assignment .)
    DOUBLE_EQ       reduce using rule 51 (expr -> assignment .)
    GREATER_THAN_EQ reduce using rule 51 (expr -> assignment .)
    LESS_THAN_EQ    reduce using rule 51 (expr -> assignment .)
    NOT_EQ          reduce using rule 51 (expr -> assignment .)
    AND             reduce using rule 51 (expr -> assignment .)
    OR              reduce using rule 51 (expr -> assignment .)
    RPAREN          reduce using rule 51 (expr -> assignment .)
    FN              reduce using rule 51 (expr -> assignment .)
    $end            reduce using rule 51 (expr -> assignment .)
    ID              reduce using rule 51 (expr -> assignment .)
    NUMBER          reduce using rule 51 (expr -> assignment .)
    STRING          reduce using rule 51 (expr -> assignment .)
    NULL            reduce using rule 51 (expr -> assignment .)
    LPAREN          reduce using rule 51 (expr -> assignment .)
    IF              reduce using rule 51 (expr -> assignment .)
    WHILE           reduce using rule 51 (expr -> assignment .)
    FOR             reduce using rule 51 (expr -> assignment .)
    DO              reduce using rule 51 (expr -> assignment .)
    RETURN          reduce using rule 51 (expr -> assignment .)
    BEGIN           reduce using rule 51 (expr -> assignment .)
    SCAN            reduce using rule 51 (expr -> assignment .)
    PRINT           reduce using rule 51 (expr -> assignment .)
    LENGTH          reduce using rule 51 (expr -> assignment .)
    EXIT            reduce using rule 51 (expr -> assignment .)
    NOT             reduce using rule 51 (expr -> assignment .)
    RCURLYEBR       reduce using rule 51 (expr -> assignment .)
    END             reduce using rule 51 (expr -> assignment .)
    ELSE            reduce using rule 51 (expr -> assignment .)
    COMMA           reduce using rule 51 (expr -> assignment .)
    RSQUAREBR       reduce using rule 51 (expr -> assignment .)
    COLON           reduce using rule 51 (expr -> assignment .)
    DOUBLE_RSQUAREBR reduce using rule 51 (expr -> assignment .)
    TO              reduce using rule 51 (expr -> assignment .)


state 62

    (53) expr -> NUMBER .

    SEMI_COLON      reduce using rule 53 (expr -> NUMBER .)
    LSQUAREBR       reduce using rule 53 (expr -> NUMBER .)
    QUESTION_MARK   reduce using rule 53 (expr -> NUMBER .)
    PLUS            reduce using rule 53 (expr -> NUMBER .)
    MINUS           reduce using rule 53 (expr -> NUMBER .)
    TIMES           reduce using rule 53 (expr -> NUMBER .)
    DIVIDE          reduce using rule 53 (expr -> NUMBER .)
    GREATER_THAN    reduce using rule 53 (expr -> NUMBER .)
    LESS_THAN       reduce using rule 53 (expr -> NUMBER .)
    DOUBLE_EQ       reduce using rule 53 (expr -> NUMBER .)
    GREATER_THAN_EQ reduce using rule 53 (expr -> NUMBER .)
    LESS_THAN_EQ    reduce using rule 53 (expr -> NUMBER .)
    NOT_EQ          reduce using rule 53 (expr -> NUMBER .)
    AND             reduce using rule 53 (expr -> NUMBER .)
    OR              reduce using rule 53 (expr -> NUMBER .)
    RPAREN          reduce using rule 53 (expr -> NUMBER .)
    FN              reduce using rule 53 (expr -> NUMBER .)
    $end            reduce using rule 53 (expr -> NUMBER .)
    ID              reduce using rule 53 (expr -> NUMBER .)
    NUMBER          reduce using rule 53 (expr -> NUMBER .)
    STRING          reduce using rule 53 (expr -> NUMBER .)
    NULL            reduce using rule 53 (expr -> NUMBER .)
    LPAREN          reduce using rule 53 (expr -> NUMBER .)
    IF              reduce using rule 53 (expr -> NUMBER .)
    WHILE           reduce using rule 53 (expr -> NUMBER .)
    FOR             reduce using rule 53 (expr -> NUMBER .)
    DO              reduce using rule 53 (expr -> NUMBER .)
    RETURN          reduce using rule 53 (expr -> NUMBER .)
    BEGIN           reduce using rule 53 (expr -> NUMBER .)
    SCAN            reduce using rule 53 (expr -> NUMBER .)
    PRINT           reduce using rule 53 (expr -> NUMBER .)
    LENGTH          reduce using rule 53 (expr -> NUMBER .)
    EXIT            reduce using rule 53 (expr -> NUMBER .)
    NOT             reduce using rule 53 (expr -> NUMBER .)
    RCURLYEBR       reduce using rule 53 (expr -> NUMBER .)
    END             reduce using rule 53 (expr -> NUMBER .)
    ELSE            reduce using rule 53 (expr -> NUMBER .)
    COMMA           reduce using rule 53 (expr -> NUMBER .)
    RSQUAREBR       reduce using rule 53 (expr -> NUMBER .)
    COLON           reduce using rule 53 (expr -> NUMBER .)
    DOUBLE_RSQUAREBR reduce using rule 53 (expr -> NUMBER .)
    TO              reduce using rule 53 (expr -> NUMBER .)


state 63

    (54) expr -> STRING .

    SEMI_COLON      reduce using rule 54 (expr -> STRING .)
    LSQUAREBR       reduce using rule 54 (expr -> STRING .)
    QUESTION_MARK   reduce using rule 54 (expr -> STRING .)
    PLUS            reduce using rule 54 (expr -> STRING .)
    MINUS           reduce using rule 54 (expr -> STRING .)
    TIMES           reduce using rule 54 (expr -> STRING .)
    DIVIDE          reduce using rule 54 (expr -> STRING .)
    GREATER_THAN    reduce using rule 54 (expr -> STRING .)
    LESS_THAN       reduce using rule 54 (expr -> STRING .)
    DOUBLE_EQ       reduce using rule 54 (expr -> STRING .)
    GREATER_THAN_EQ reduce using rule 54 (expr -> STRING .)
    LESS_THAN_EQ    reduce using rule 54 (expr -> STRING .)
    NOT_EQ          reduce using rule 54 (expr -> STRING .)
    AND             reduce using rule 54 (expr -> STRING .)
    OR              reduce using rule 54 (expr -> STRING .)
    RPAREN          reduce using rule 54 (expr -> STRING .)
    FN              reduce using rule 54 (expr -> STRING .)
    $end            reduce using rule 54 (expr -> STRING .)
    ID              reduce using rule 54 (expr -> STRING .)
    NUMBER          reduce using rule 54 (expr -> STRING .)
    STRING          reduce using rule 54 (expr -> STRING .)
    NULL            reduce using rule 54 (expr -> STRING .)
    LPAREN          reduce using rule 54 (expr -> STRING .)
    IF              reduce using rule 54 (expr -> STRING .)
    WHILE           reduce using rule 54 (expr -> STRING .)
    FOR             reduce using rule 54 (expr -> STRING .)
    DO              reduce using rule 54 (expr -> STRING .)
    RETURN          reduce using rule 54 (expr -> STRING .)
    BEGIN           reduce using rule 54 (expr -> STRING .)
    SCAN            reduce using rule 54 (expr -> STRING .)
    PRINT           reduce using rule 54 (expr -> STRING .)
    LENGTH          reduce using rule 54 (expr -> STRING .)
    EXIT            reduce using rule 54 (expr -> STRING .)
    NOT             reduce using rule 54 (expr -> STRING .)
    RCURLYEBR       reduce using rule 54 (expr -> STRING .)
    END             reduce using rule 54 (expr -> STRING .)
    ELSE            reduce using rule 54 (expr -> STRING .)
    COMMA           reduce using rule 54 (expr -> STRING .)
    RSQUAREBR       reduce using rule 54 (expr -> STRING .)
    COLON           reduce using rule 54 (expr -> STRING .)
    DOUBLE_RSQUAREBR reduce using rule 54 (expr -> STRING .)
    TO              reduce using rule 54 (expr -> STRING .)


state 64

    (55) expr -> NULL .

    SEMI_COLON      reduce using rule 55 (expr -> NULL .)
    LSQUAREBR       reduce using rule 55 (expr -> NULL .)
    QUESTION_MARK   reduce using rule 55 (expr -> NULL .)
    PLUS            reduce using rule 55 (expr -> NULL .)
    MINUS           reduce using rule 55 (expr -> NULL .)
    TIMES           reduce using rule 55 (expr -> NULL .)
    DIVIDE          reduce using rule 55 (expr -> NULL .)
    GREATER_THAN    reduce using rule 55 (expr -> NULL .)
    LESS_THAN       reduce using rule 55 (expr -> NULL .)
    DOUBLE_EQ       reduce using rule 55 (expr -> NULL .)
    GREATER_THAN_EQ reduce using rule 55 (expr -> NULL .)
    LESS_THAN_EQ    reduce using rule 55 (expr -> NULL .)
    NOT_EQ          reduce using rule 55 (expr -> NULL .)
    AND             reduce using rule 55 (expr -> NULL .)
    OR              reduce using rule 55 (expr -> NULL .)
    RPAREN          reduce using rule 55 (expr -> NULL .)
    FN              reduce using rule 55 (expr -> NULL .)
    $end            reduce using rule 55 (expr -> NULL .)
    ID              reduce using rule 55 (expr -> NULL .)
    NUMBER          reduce using rule 55 (expr -> NULL .)
    STRING          reduce using rule 55 (expr -> NULL .)
    NULL            reduce using rule 55 (expr -> NULL .)
    LPAREN          reduce using rule 55 (expr -> NULL .)
    IF              reduce using rule 55 (expr -> NULL .)
    WHILE           reduce using rule 55 (expr -> NULL .)
    FOR             reduce using rule 55 (expr -> NULL .)
    DO              reduce using rule 55 (expr -> NULL .)
    RETURN          reduce using rule 55 (expr -> NULL .)
    BEGIN           reduce using rule 55 (expr -> NULL .)
    SCAN            reduce using rule 55 (expr -> NULL .)
    PRINT           reduce using rule 55 (expr -> NULL .)
    LENGTH          reduce using rule 55 (expr -> NULL .)
    EXIT            reduce using rule 55 (expr -> NULL .)
    NOT             reduce using rule 55 (expr -> NULL .)
    RCURLYEBR       reduce using rule 55 (expr -> NULL .)
    END             reduce using rule 55 (expr -> NULL .)
    ELSE            reduce using rule 55 (expr -> NULL .)
    COMMA           reduce using rule 55 (expr -> NULL .)
    RSQUAREBR       reduce using rule 55 (expr -> NULL .)
    COLON           reduce using rule 55 (expr -> NULL .)
    DOUBLE_RSQUAREBR reduce using rule 55 (expr -> NULL .)
    TO              reduce using rule 55 (expr -> NULL .)


state 65

    (28) single_if -> IF . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> IF . LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> IF . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> IF . DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt

    DOUBLE_LSQUAREBR shift and go to state 108
    LCURLYEBR       shift and go to state 109


state 66

    (24) while_loop -> WHILE . LPAREN expr RPAREN stmt
    (82) while_loop -> WHILE . LPAREN error RPAREN stmt

    LPAREN          shift and go to state 110


state 67

    (25) for_loop -> FOR . LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> FOR . LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> FOR . LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> FOR . LPAREN ID EQ error TO error RPAREN stmt

    LPAREN          shift and go to state 111


state 68

    (26) do_while -> DO . stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 112
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 69

    (22) return_is -> RETURN . expr
    (23) return_is -> RETURN .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for NUMBER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMI_COLON      reduce using rule 23 (return_is -> RETURN .)
    FN              reduce using rule 23 (return_is -> RETURN .)
    $end            reduce using rule 23 (return_is -> RETURN .)
    IF              reduce using rule 23 (return_is -> RETURN .)
    WHILE           reduce using rule 23 (return_is -> RETURN .)
    FOR             reduce using rule 23 (return_is -> RETURN .)
    DO              reduce using rule 23 (return_is -> RETURN .)
    RETURN          reduce using rule 23 (return_is -> RETURN .)
    BEGIN           reduce using rule 23 (return_is -> RETURN .)
    SCAN            reduce using rule 23 (return_is -> RETURN .)
    PRINT           reduce using rule 23 (return_is -> RETURN .)
    LENGTH          reduce using rule 23 (return_is -> RETURN .)
    EXIT            reduce using rule 23 (return_is -> RETURN .)
    RCURLYEBR       reduce using rule 23 (return_is -> RETURN .)
    END             reduce using rule 23 (return_is -> RETURN .)
    ELSE            reduce using rule 23 (return_is -> RETURN .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

  ! ID              [ reduce using rule 23 (return_is -> RETURN .) ]
  ! NUMBER          [ reduce using rule 23 (return_is -> RETURN .) ]
  ! STRING          [ reduce using rule 23 (return_is -> RETURN .) ]
  ! NULL            [ reduce using rule 23 (return_is -> RETURN .) ]
  ! LPAREN          [ reduce using rule 23 (return_is -> RETURN .) ]
  ! LSQUAREBR       [ reduce using rule 23 (return_is -> RETURN .) ]
  ! NOT             [ reduce using rule 23 (return_is -> RETURN .) ]
  ! PLUS            [ reduce using rule 23 (return_is -> RETURN .) ]
  ! MINUS           [ reduce using rule 23 (return_is -> RETURN .) ]

    expr                           shift and go to state 113
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 70

    (27) block -> BEGIN . body END
    (20) body -> . empty
    (21) body -> . stmt body
    (5) empty -> .
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    END             reduce using rule 5 (empty -> .)
    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    body                           shift and go to state 114
    empty                          shift and go to state 40
    stmt                           shift and go to state 41
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 71

    (77) builtin_methods -> SCAN . LPAREN RPAREN

    LPAREN          shift and go to state 115


state 72

    (78) builtin_methods -> PRINT . LPAREN clist RPAREN

    LPAREN          shift and go to state 116


state 73

    (79) builtin_methods -> LENGTH . LPAREN clist RPAREN

    LPAREN          shift and go to state 117


state 74

    (80) builtin_methods -> EXIT . LPAREN clist RPAREN

    LPAREN          shift and go to state 118


state 75

    (59) expr_list -> LSQUAREBR . clist RSQUAREBR
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RSQUAREBR       reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    clist                          shift and go to state 119
    empty                          shift and go to state 120
    expr                           shift and go to state 121
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 76

    (75) single_expr -> PLUS . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 122
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 77

    (76) single_expr -> MINUS . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 123
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 78

    (74) single_expr -> NOT . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 124
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 79

    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN . return_is
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN

    RETURN          shift and go to state 69

    return_is                      shift and go to state 125

state 80

    (30) defvar -> ID DBL_COLON . type
    (31) defvar -> ID DBL_COLON . type EQ expr
    (32) type -> . INT
    (33) type -> . STRING
    (34) type -> . VECTOR
    (35) type -> . NULL
    (36) type -> . BOOLEAN

    INT             shift and go to state 19
    STRING          shift and go to state 20
    VECTOR          shift and go to state 21
    NULL            shift and go to state 22
    BOOLEAN         shift and go to state 23

    type                           shift and go to state 126

state 81

    (57) assignment -> ID EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 127
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 82

    (61) function_call -> ID LPAREN . clist RPAREN
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    clist                          shift and go to state 128
    empty                          shift and go to state 120
    expr                           shift and go to state 121
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 83

    (56) expr -> LPAREN expr . RPAREN
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 129
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 84

    (50) expr -> ID .
    (57) assignment -> ID . EQ expr
    (61) function_call -> ID . LPAREN clist RPAREN

  ! shift/reduce conflict for LPAREN resolved as shift
    RPAREN          reduce using rule 50 (expr -> ID .)
    LSQUAREBR       reduce using rule 50 (expr -> ID .)
    QUESTION_MARK   reduce using rule 50 (expr -> ID .)
    PLUS            reduce using rule 50 (expr -> ID .)
    MINUS           reduce using rule 50 (expr -> ID .)
    TIMES           reduce using rule 50 (expr -> ID .)
    DIVIDE          reduce using rule 50 (expr -> ID .)
    GREATER_THAN    reduce using rule 50 (expr -> ID .)
    LESS_THAN       reduce using rule 50 (expr -> ID .)
    DOUBLE_EQ       reduce using rule 50 (expr -> ID .)
    GREATER_THAN_EQ reduce using rule 50 (expr -> ID .)
    LESS_THAN_EQ    reduce using rule 50 (expr -> ID .)
    NOT_EQ          reduce using rule 50 (expr -> ID .)
    AND             reduce using rule 50 (expr -> ID .)
    OR              reduce using rule 50 (expr -> ID .)
    SEMI_COLON      reduce using rule 50 (expr -> ID .)
    FN              reduce using rule 50 (expr -> ID .)
    $end            reduce using rule 50 (expr -> ID .)
    ID              reduce using rule 50 (expr -> ID .)
    NUMBER          reduce using rule 50 (expr -> ID .)
    STRING          reduce using rule 50 (expr -> ID .)
    NULL            reduce using rule 50 (expr -> ID .)
    IF              reduce using rule 50 (expr -> ID .)
    WHILE           reduce using rule 50 (expr -> ID .)
    FOR             reduce using rule 50 (expr -> ID .)
    DO              reduce using rule 50 (expr -> ID .)
    RETURN          reduce using rule 50 (expr -> ID .)
    BEGIN           reduce using rule 50 (expr -> ID .)
    SCAN            reduce using rule 50 (expr -> ID .)
    PRINT           reduce using rule 50 (expr -> ID .)
    LENGTH          reduce using rule 50 (expr -> ID .)
    EXIT            reduce using rule 50 (expr -> ID .)
    NOT             reduce using rule 50 (expr -> ID .)
    RCURLYEBR       reduce using rule 50 (expr -> ID .)
    END             reduce using rule 50 (expr -> ID .)
    ELSE            reduce using rule 50 (expr -> ID .)
    COMMA           reduce using rule 50 (expr -> ID .)
    RSQUAREBR       reduce using rule 50 (expr -> ID .)
    COLON           reduce using rule 50 (expr -> ID .)
    DOUBLE_RSQUAREBR reduce using rule 50 (expr -> ID .)
    TO              reduce using rule 50 (expr -> ID .)
    EQ              shift and go to state 81
    LPAREN          shift and go to state 82

  ! LPAREN          [ reduce using rule 50 (expr -> ID .) ]


state 85

    (52) expr -> function_call .

    RPAREN          reduce using rule 52 (expr -> function_call .)
    LSQUAREBR       reduce using rule 52 (expr -> function_call .)
    QUESTION_MARK   reduce using rule 52 (expr -> function_call .)
    PLUS            reduce using rule 52 (expr -> function_call .)
    MINUS           reduce using rule 52 (expr -> function_call .)
    TIMES           reduce using rule 52 (expr -> function_call .)
    DIVIDE          reduce using rule 52 (expr -> function_call .)
    GREATER_THAN    reduce using rule 52 (expr -> function_call .)
    LESS_THAN       reduce using rule 52 (expr -> function_call .)
    DOUBLE_EQ       reduce using rule 52 (expr -> function_call .)
    GREATER_THAN_EQ reduce using rule 52 (expr -> function_call .)
    LESS_THAN_EQ    reduce using rule 52 (expr -> function_call .)
    NOT_EQ          reduce using rule 52 (expr -> function_call .)
    AND             reduce using rule 52 (expr -> function_call .)
    OR              reduce using rule 52 (expr -> function_call .)
    SEMI_COLON      reduce using rule 52 (expr -> function_call .)
    FN              reduce using rule 52 (expr -> function_call .)
    $end            reduce using rule 52 (expr -> function_call .)
    ID              reduce using rule 52 (expr -> function_call .)
    NUMBER          reduce using rule 52 (expr -> function_call .)
    STRING          reduce using rule 52 (expr -> function_call .)
    NULL            reduce using rule 52 (expr -> function_call .)
    LPAREN          reduce using rule 52 (expr -> function_call .)
    IF              reduce using rule 52 (expr -> function_call .)
    WHILE           reduce using rule 52 (expr -> function_call .)
    FOR             reduce using rule 52 (expr -> function_call .)
    DO              reduce using rule 52 (expr -> function_call .)
    RETURN          reduce using rule 52 (expr -> function_call .)
    BEGIN           reduce using rule 52 (expr -> function_call .)
    SCAN            reduce using rule 52 (expr -> function_call .)
    PRINT           reduce using rule 52 (expr -> function_call .)
    LENGTH          reduce using rule 52 (expr -> function_call .)
    EXIT            reduce using rule 52 (expr -> function_call .)
    NOT             reduce using rule 52 (expr -> function_call .)
    RCURLYEBR       reduce using rule 52 (expr -> function_call .)
    END             reduce using rule 52 (expr -> function_call .)
    ELSE            reduce using rule 52 (expr -> function_call .)
    COMMA           reduce using rule 52 (expr -> function_call .)
    RSQUAREBR       reduce using rule 52 (expr -> function_call .)
    COLON           reduce using rule 52 (expr -> function_call .)
    DOUBLE_RSQUAREBR reduce using rule 52 (expr -> function_call .)
    TO              reduce using rule 52 (expr -> function_call .)


state 86

    (37) func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .

    FN              reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    $end            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    ID              reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    NUMBER          reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    STRING          reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    NULL            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    LPAREN          reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    IF              reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    WHILE           reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    FOR             reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    DO              reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    RETURN          reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    BEGIN           reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    SCAN            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    PRINT           reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    LENGTH          reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    EXIT            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    LSQUAREBR       reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    NOT             reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    PLUS            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    MINUS           reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    RCURLYEBR       reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    SEMI_COLON      reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    END             reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)
    ELSE            reduce using rule 37 (func1 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR .)


state 87

    (21) body -> stmt body .

    RCURLYEBR       reduce using rule 21 (body -> stmt body .)
    END             reduce using rule 21 (body -> stmt body .)


state 88

    (6) stmt -> expr SEMI_COLON .

    ID              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    NUMBER          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    STRING          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    NULL            reduce using rule 6 (stmt -> expr SEMI_COLON .)
    LPAREN          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    IF              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    WHILE           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    FOR             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    DO              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    RETURN          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    BEGIN           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    SCAN            reduce using rule 6 (stmt -> expr SEMI_COLON .)
    PRINT           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    LENGTH          reduce using rule 6 (stmt -> expr SEMI_COLON .)
    EXIT            reduce using rule 6 (stmt -> expr SEMI_COLON .)
    FN              reduce using rule 6 (stmt -> expr SEMI_COLON .)
    LSQUAREBR       reduce using rule 6 (stmt -> expr SEMI_COLON .)
    NOT             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    PLUS            reduce using rule 6 (stmt -> expr SEMI_COLON .)
    MINUS           reduce using rule 6 (stmt -> expr SEMI_COLON .)
    RCURLYEBR       reduce using rule 6 (stmt -> expr SEMI_COLON .)
    END             reduce using rule 6 (stmt -> expr SEMI_COLON .)
    ELSE            reduce using rule 6 (stmt -> expr SEMI_COLON .)


state 89

    (58) on_list -> expr LSQUAREBR . expr RSQUAREBR
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 130
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 90

    (60) ternary_expr -> expr QUESTION_MARK . expr COLON expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 131
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 91

    (62) binary_expr -> expr PLUS . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 132
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 92

    (63) binary_expr -> expr MINUS . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 133
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 93

    (64) binary_expr -> expr TIMES . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 134
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 94

    (65) binary_expr -> expr DIVIDE . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 135
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 95

    (66) binary_expr -> expr GREATER_THAN . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 136
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 96

    (67) binary_expr -> expr LESS_THAN . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 137
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 97

    (68) binary_expr -> expr DOUBLE_EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 138
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 98

    (69) binary_expr -> expr GREATER_THAN_EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 139
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 99

    (70) binary_expr -> expr LESS_THAN_EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 140
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 100

    (71) binary_expr -> expr NOT_EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 141
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 101

    (72) binary_expr -> expr AND . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 142
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 102

    (73) binary_expr -> expr OR . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 143
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 103

    (7) stmt -> defvar SEMI_COLON .

    ID              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    NUMBER          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    STRING          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    NULL            reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    LPAREN          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    IF              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    WHILE           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    FOR             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    DO              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    RETURN          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    BEGIN           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    SCAN            reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    PRINT           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    LENGTH          reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    EXIT            reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    FN              reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    LSQUAREBR       reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    NOT             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    PLUS            reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    MINUS           reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    RCURLYEBR       reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    END             reduce using rule 7 (stmt -> defvar SEMI_COLON .)
    ELSE            reduce using rule 7 (stmt -> defvar SEMI_COLON .)


state 104

    (8) stmt -> func SEMI_COLON .

    ID              reduce using rule 8 (stmt -> func SEMI_COLON .)
    NUMBER          reduce using rule 8 (stmt -> func SEMI_COLON .)
    STRING          reduce using rule 8 (stmt -> func SEMI_COLON .)
    NULL            reduce using rule 8 (stmt -> func SEMI_COLON .)
    LPAREN          reduce using rule 8 (stmt -> func SEMI_COLON .)
    IF              reduce using rule 8 (stmt -> func SEMI_COLON .)
    WHILE           reduce using rule 8 (stmt -> func SEMI_COLON .)
    FOR             reduce using rule 8 (stmt -> func SEMI_COLON .)
    DO              reduce using rule 8 (stmt -> func SEMI_COLON .)
    RETURN          reduce using rule 8 (stmt -> func SEMI_COLON .)
    BEGIN           reduce using rule 8 (stmt -> func SEMI_COLON .)
    SCAN            reduce using rule 8 (stmt -> func SEMI_COLON .)
    PRINT           reduce using rule 8 (stmt -> func SEMI_COLON .)
    LENGTH          reduce using rule 8 (stmt -> func SEMI_COLON .)
    EXIT            reduce using rule 8 (stmt -> func SEMI_COLON .)
    FN              reduce using rule 8 (stmt -> func SEMI_COLON .)
    LSQUAREBR       reduce using rule 8 (stmt -> func SEMI_COLON .)
    NOT             reduce using rule 8 (stmt -> func SEMI_COLON .)
    PLUS            reduce using rule 8 (stmt -> func SEMI_COLON .)
    MINUS           reduce using rule 8 (stmt -> func SEMI_COLON .)
    RCURLYEBR       reduce using rule 8 (stmt -> func SEMI_COLON .)
    END             reduce using rule 8 (stmt -> func SEMI_COLON .)
    ELSE            reduce using rule 8 (stmt -> func SEMI_COLON .)


state 105

    (14) stmt -> return_is SEMI_COLON .

    ID              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    NUMBER          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    STRING          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    NULL            reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    LPAREN          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    IF              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    WHILE           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    FOR             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    DO              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    RETURN          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    BEGIN           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    SCAN            reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    PRINT           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    LENGTH          reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    EXIT            reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    FN              reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    LSQUAREBR       reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    NOT             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    PLUS            reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    MINUS           reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    RCURLYEBR       reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    END             reduce using rule 14 (stmt -> return_is SEMI_COLON .)
    ELSE            reduce using rule 14 (stmt -> return_is SEMI_COLON .)


state 106

    (16) stmt -> builtin_methods SEMI_COLON .

    ID              reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    NUMBER          reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    STRING          reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    NULL            reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    LPAREN          reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    IF              reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    WHILE           reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    FOR             reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    DO              reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    RETURN          reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    BEGIN           reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    SCAN            reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    PRINT           reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    LENGTH          reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    EXIT            reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    FN              reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    LSQUAREBR       reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    NOT             reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    PLUS            reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    MINUS           reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    RCURLYEBR       reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    END             reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)
    ELSE            reduce using rule 16 (stmt -> builtin_methods SEMI_COLON .)


state 107

    (17) stmt -> function_call SEMI_COLON .

    ID              reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    NUMBER          reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    STRING          reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    NULL            reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    LPAREN          reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    IF              reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    WHILE           reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    FOR             reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    DO              reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    RETURN          reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    BEGIN           reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    SCAN            reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    PRINT           reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    LENGTH          reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    EXIT            reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    FN              reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    LSQUAREBR       reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    NOT             reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    PLUS            reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    MINUS           reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    RCURLYEBR       reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    END             reduce using rule 17 (stmt -> function_call SEMI_COLON .)
    ELSE            reduce using rule 17 (stmt -> function_call SEMI_COLON .)


state 108

    (28) single_if -> IF DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR stmt
    (29) else_if -> IF DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> IF DOUBLE_LSQUAREBR . error DOUBLE_RSQUAREBR stmt ELSE stmt
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 145
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 144
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 109

    (81) single_if -> IF LCURLYEBR . error RCURLYEBR stmt

    error           shift and go to state 146


state 110

    (24) while_loop -> WHILE LPAREN . expr RPAREN stmt
    (82) while_loop -> WHILE LPAREN . error RPAREN stmt
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 148
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 147
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 111

    (25) for_loop -> FOR LPAREN . ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> FOR LPAREN . ID EQ error TO expr RPAREN stmt
    (88) for_loop -> FOR LPAREN . ID EQ expr TO error RPAREN stmt
    (89) for_loop -> FOR LPAREN . ID EQ error TO error RPAREN stmt

    ID              shift and go to state 149


state 112

    (26) do_while -> DO stmt . WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR

    WHILE           shift and go to state 150


state 113

    (22) return_is -> RETURN expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    SEMI_COLON      reduce using rule 22 (return_is -> RETURN expr .)
    FN              reduce using rule 22 (return_is -> RETURN expr .)
    $end            reduce using rule 22 (return_is -> RETURN expr .)
    ID              reduce using rule 22 (return_is -> RETURN expr .)
    NUMBER          reduce using rule 22 (return_is -> RETURN expr .)
    STRING          reduce using rule 22 (return_is -> RETURN expr .)
    NULL            reduce using rule 22 (return_is -> RETURN expr .)
    LPAREN          reduce using rule 22 (return_is -> RETURN expr .)
    IF              reduce using rule 22 (return_is -> RETURN expr .)
    WHILE           reduce using rule 22 (return_is -> RETURN expr .)
    FOR             reduce using rule 22 (return_is -> RETURN expr .)
    DO              reduce using rule 22 (return_is -> RETURN expr .)
    RETURN          reduce using rule 22 (return_is -> RETURN expr .)
    BEGIN           reduce using rule 22 (return_is -> RETURN expr .)
    SCAN            reduce using rule 22 (return_is -> RETURN expr .)
    PRINT           reduce using rule 22 (return_is -> RETURN expr .)
    LENGTH          reduce using rule 22 (return_is -> RETURN expr .)
    EXIT            reduce using rule 22 (return_is -> RETURN expr .)
    NOT             reduce using rule 22 (return_is -> RETURN expr .)
    RCURLYEBR       reduce using rule 22 (return_is -> RETURN expr .)
    END             reduce using rule 22 (return_is -> RETURN expr .)
    ELSE            reduce using rule 22 (return_is -> RETURN expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 22 (return_is -> RETURN expr .) ]
  ! PLUS            [ reduce using rule 22 (return_is -> RETURN expr .) ]
  ! MINUS           [ reduce using rule 22 (return_is -> RETURN expr .) ]


state 114

    (27) block -> BEGIN body . END

    END             shift and go to state 151


state 115

    (77) builtin_methods -> SCAN LPAREN . RPAREN

    RPAREN          shift and go to state 152


state 116

    (78) builtin_methods -> PRINT LPAREN . clist RPAREN
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    clist                          shift and go to state 153
    empty                          shift and go to state 120
    expr                           shift and go to state 121
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 117

    (79) builtin_methods -> LENGTH LPAREN . clist RPAREN
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    clist                          shift and go to state 154
    empty                          shift and go to state 120
    expr                           shift and go to state 121
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 118

    (80) builtin_methods -> EXIT LPAREN . clist RPAREN
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    clist                          shift and go to state 155
    empty                          shift and go to state 120
    expr                           shift and go to state 121
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 119

    (59) expr_list -> LSQUAREBR clist . RSQUAREBR

    RSQUAREBR       shift and go to state 156


state 120

    (42) clist -> empty .

    RSQUAREBR       reduce using rule 42 (clist -> empty .)
    RPAREN          reduce using rule 42 (clist -> empty .)


state 121

    (43) clist -> expr .
    (44) clist -> expr . COMMA clist
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RSQUAREBR       reduce using rule 43 (clist -> expr .)
    RPAREN          reduce using rule 43 (clist -> expr .)
    COMMA           shift and go to state 157
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 122

    (75) single_expr -> PLUS expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 75 (single_expr -> PLUS expr .)
    RPAREN          reduce using rule 75 (single_expr -> PLUS expr .)
    FN              reduce using rule 75 (single_expr -> PLUS expr .)
    $end            reduce using rule 75 (single_expr -> PLUS expr .)
    ID              reduce using rule 75 (single_expr -> PLUS expr .)
    NUMBER          reduce using rule 75 (single_expr -> PLUS expr .)
    STRING          reduce using rule 75 (single_expr -> PLUS expr .)
    NULL            reduce using rule 75 (single_expr -> PLUS expr .)
    LPAREN          reduce using rule 75 (single_expr -> PLUS expr .)
    IF              reduce using rule 75 (single_expr -> PLUS expr .)
    WHILE           reduce using rule 75 (single_expr -> PLUS expr .)
    FOR             reduce using rule 75 (single_expr -> PLUS expr .)
    DO              reduce using rule 75 (single_expr -> PLUS expr .)
    RETURN          reduce using rule 75 (single_expr -> PLUS expr .)
    BEGIN           reduce using rule 75 (single_expr -> PLUS expr .)
    SCAN            reduce using rule 75 (single_expr -> PLUS expr .)
    PRINT           reduce using rule 75 (single_expr -> PLUS expr .)
    LENGTH          reduce using rule 75 (single_expr -> PLUS expr .)
    EXIT            reduce using rule 75 (single_expr -> PLUS expr .)
    NOT             reduce using rule 75 (single_expr -> PLUS expr .)
    RCURLYEBR       reduce using rule 75 (single_expr -> PLUS expr .)
    END             reduce using rule 75 (single_expr -> PLUS expr .)
    ELSE            reduce using rule 75 (single_expr -> PLUS expr .)
    COMMA           reduce using rule 75 (single_expr -> PLUS expr .)
    RSQUAREBR       reduce using rule 75 (single_expr -> PLUS expr .)
    COLON           reduce using rule 75 (single_expr -> PLUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 75 (single_expr -> PLUS expr .)
    TO              reduce using rule 75 (single_expr -> PLUS expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! PLUS            [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! MINUS           [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! TIMES           [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! LESS_THAN       [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! NOT_EQ          [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! AND             [ reduce using rule 75 (single_expr -> PLUS expr .) ]
  ! OR              [ reduce using rule 75 (single_expr -> PLUS expr .) ]


state 123

    (76) single_expr -> MINUS expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 76 (single_expr -> MINUS expr .)
    RPAREN          reduce using rule 76 (single_expr -> MINUS expr .)
    FN              reduce using rule 76 (single_expr -> MINUS expr .)
    $end            reduce using rule 76 (single_expr -> MINUS expr .)
    ID              reduce using rule 76 (single_expr -> MINUS expr .)
    NUMBER          reduce using rule 76 (single_expr -> MINUS expr .)
    STRING          reduce using rule 76 (single_expr -> MINUS expr .)
    NULL            reduce using rule 76 (single_expr -> MINUS expr .)
    LPAREN          reduce using rule 76 (single_expr -> MINUS expr .)
    IF              reduce using rule 76 (single_expr -> MINUS expr .)
    WHILE           reduce using rule 76 (single_expr -> MINUS expr .)
    FOR             reduce using rule 76 (single_expr -> MINUS expr .)
    DO              reduce using rule 76 (single_expr -> MINUS expr .)
    RETURN          reduce using rule 76 (single_expr -> MINUS expr .)
    BEGIN           reduce using rule 76 (single_expr -> MINUS expr .)
    SCAN            reduce using rule 76 (single_expr -> MINUS expr .)
    PRINT           reduce using rule 76 (single_expr -> MINUS expr .)
    LENGTH          reduce using rule 76 (single_expr -> MINUS expr .)
    EXIT            reduce using rule 76 (single_expr -> MINUS expr .)
    NOT             reduce using rule 76 (single_expr -> MINUS expr .)
    RCURLYEBR       reduce using rule 76 (single_expr -> MINUS expr .)
    END             reduce using rule 76 (single_expr -> MINUS expr .)
    ELSE            reduce using rule 76 (single_expr -> MINUS expr .)
    COMMA           reduce using rule 76 (single_expr -> MINUS expr .)
    RSQUAREBR       reduce using rule 76 (single_expr -> MINUS expr .)
    COLON           reduce using rule 76 (single_expr -> MINUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 76 (single_expr -> MINUS expr .)
    TO              reduce using rule 76 (single_expr -> MINUS expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! PLUS            [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! MINUS           [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! TIMES           [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! LESS_THAN       [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! NOT_EQ          [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! AND             [ reduce using rule 76 (single_expr -> MINUS expr .) ]
  ! OR              [ reduce using rule 76 (single_expr -> MINUS expr .) ]


state 124

    (74) single_expr -> NOT expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 74 (single_expr -> NOT expr .)
    RPAREN          reduce using rule 74 (single_expr -> NOT expr .)
    FN              reduce using rule 74 (single_expr -> NOT expr .)
    $end            reduce using rule 74 (single_expr -> NOT expr .)
    ID              reduce using rule 74 (single_expr -> NOT expr .)
    NUMBER          reduce using rule 74 (single_expr -> NOT expr .)
    STRING          reduce using rule 74 (single_expr -> NOT expr .)
    NULL            reduce using rule 74 (single_expr -> NOT expr .)
    LPAREN          reduce using rule 74 (single_expr -> NOT expr .)
    IF              reduce using rule 74 (single_expr -> NOT expr .)
    WHILE           reduce using rule 74 (single_expr -> NOT expr .)
    FOR             reduce using rule 74 (single_expr -> NOT expr .)
    DO              reduce using rule 74 (single_expr -> NOT expr .)
    RETURN          reduce using rule 74 (single_expr -> NOT expr .)
    BEGIN           reduce using rule 74 (single_expr -> NOT expr .)
    SCAN            reduce using rule 74 (single_expr -> NOT expr .)
    PRINT           reduce using rule 74 (single_expr -> NOT expr .)
    LENGTH          reduce using rule 74 (single_expr -> NOT expr .)
    EXIT            reduce using rule 74 (single_expr -> NOT expr .)
    NOT             reduce using rule 74 (single_expr -> NOT expr .)
    RCURLYEBR       reduce using rule 74 (single_expr -> NOT expr .)
    END             reduce using rule 74 (single_expr -> NOT expr .)
    ELSE            reduce using rule 74 (single_expr -> NOT expr .)
    COMMA           reduce using rule 74 (single_expr -> NOT expr .)
    RSQUAREBR       reduce using rule 74 (single_expr -> NOT expr .)
    COLON           reduce using rule 74 (single_expr -> NOT expr .)
    DOUBLE_RSQUAREBR reduce using rule 74 (single_expr -> NOT expr .)
    TO              reduce using rule 74 (single_expr -> NOT expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! QUESTION_MARK   [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! PLUS            [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! MINUS           [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! TIMES           [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! DIVIDE          [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! GREATER_THAN    [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! LESS_THAN       [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! NOT_EQ          [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! AND             [ reduce using rule 74 (single_expr -> NOT expr .) ]
  ! OR              [ reduce using rule 74 (single_expr -> NOT expr .) ]


state 125

    (38) func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .

    FN              reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    $end            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    ID              reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    NUMBER          reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    STRING          reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    NULL            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    LPAREN          reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    IF              reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    WHILE           reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    FOR             reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    DO              reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    RETURN          reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    BEGIN           reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    SCAN            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    PRINT           reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    LENGTH          reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    EXIT            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    LSQUAREBR       reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    NOT             reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    PLUS            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    MINUS           reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    RCURLYEBR       reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    SEMI_COLON      reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    END             reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)
    ELSE            reduce using rule 38 (func2 -> FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is .)


state 126

    (30) defvar -> ID DBL_COLON type .
    (31) defvar -> ID DBL_COLON type . EQ expr

    SEMI_COLON      reduce using rule 30 (defvar -> ID DBL_COLON type .)
    EQ              shift and go to state 158


state 127

    (57) assignment -> ID EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 57 (assignment -> ID EQ expr .)
    RPAREN          reduce using rule 57 (assignment -> ID EQ expr .)
    FN              reduce using rule 57 (assignment -> ID EQ expr .)
    $end            reduce using rule 57 (assignment -> ID EQ expr .)
    ID              reduce using rule 57 (assignment -> ID EQ expr .)
    NUMBER          reduce using rule 57 (assignment -> ID EQ expr .)
    STRING          reduce using rule 57 (assignment -> ID EQ expr .)
    NULL            reduce using rule 57 (assignment -> ID EQ expr .)
    LPAREN          reduce using rule 57 (assignment -> ID EQ expr .)
    IF              reduce using rule 57 (assignment -> ID EQ expr .)
    WHILE           reduce using rule 57 (assignment -> ID EQ expr .)
    FOR             reduce using rule 57 (assignment -> ID EQ expr .)
    DO              reduce using rule 57 (assignment -> ID EQ expr .)
    RETURN          reduce using rule 57 (assignment -> ID EQ expr .)
    BEGIN           reduce using rule 57 (assignment -> ID EQ expr .)
    SCAN            reduce using rule 57 (assignment -> ID EQ expr .)
    PRINT           reduce using rule 57 (assignment -> ID EQ expr .)
    LENGTH          reduce using rule 57 (assignment -> ID EQ expr .)
    EXIT            reduce using rule 57 (assignment -> ID EQ expr .)
    NOT             reduce using rule 57 (assignment -> ID EQ expr .)
    RCURLYEBR       reduce using rule 57 (assignment -> ID EQ expr .)
    END             reduce using rule 57 (assignment -> ID EQ expr .)
    ELSE            reduce using rule 57 (assignment -> ID EQ expr .)
    COMMA           reduce using rule 57 (assignment -> ID EQ expr .)
    RSQUAREBR       reduce using rule 57 (assignment -> ID EQ expr .)
    COLON           reduce using rule 57 (assignment -> ID EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 57 (assignment -> ID EQ expr .)
    TO              reduce using rule 57 (assignment -> ID EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! PLUS            [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! MINUS           [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! TIMES           [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! DIVIDE          [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! AND             [ reduce using rule 57 (assignment -> ID EQ expr .) ]
  ! OR              [ reduce using rule 57 (assignment -> ID EQ expr .) ]


state 128

    (61) function_call -> ID LPAREN clist . RPAREN

    RPAREN          shift and go to state 159


state 129

    (56) expr -> LPAREN expr RPAREN .

    SEMI_COLON      reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LSQUAREBR       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    QUESTION_MARK   reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GREATER_THAN    reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LESS_THAN       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DOUBLE_EQ       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    GREATER_THAN_EQ reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LESS_THAN_EQ    reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NOT_EQ          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    FN              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ID              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NUMBER          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    STRING          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NULL            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LPAREN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    IF              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    WHILE           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    FOR             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DO              reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RETURN          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    BEGIN           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    SCAN            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    PRINT           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    LENGTH          reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    EXIT            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    NOT             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RCURLYEBR       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    END             reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    ELSE            reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    RSQUAREBR       reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    DOUBLE_RSQUAREBR reduce using rule 56 (expr -> LPAREN expr RPAREN .)
    TO              reduce using rule 56 (expr -> LPAREN expr RPAREN .)


state 130

    (58) on_list -> expr LSQUAREBR expr . RSQUAREBR
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RSQUAREBR       shift and go to state 160
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 131

    (60) ternary_expr -> expr QUESTION_MARK expr . COLON expr
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    COLON           shift and go to state 161
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 132

    (62) binary_expr -> expr PLUS expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 62 (binary_expr -> expr PLUS expr .)
    RPAREN          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    FN              reduce using rule 62 (binary_expr -> expr PLUS expr .)
    $end            reduce using rule 62 (binary_expr -> expr PLUS expr .)
    ID              reduce using rule 62 (binary_expr -> expr PLUS expr .)
    NUMBER          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    STRING          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    NULL            reduce using rule 62 (binary_expr -> expr PLUS expr .)
    LPAREN          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    IF              reduce using rule 62 (binary_expr -> expr PLUS expr .)
    WHILE           reduce using rule 62 (binary_expr -> expr PLUS expr .)
    FOR             reduce using rule 62 (binary_expr -> expr PLUS expr .)
    DO              reduce using rule 62 (binary_expr -> expr PLUS expr .)
    RETURN          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    BEGIN           reduce using rule 62 (binary_expr -> expr PLUS expr .)
    SCAN            reduce using rule 62 (binary_expr -> expr PLUS expr .)
    PRINT           reduce using rule 62 (binary_expr -> expr PLUS expr .)
    LENGTH          reduce using rule 62 (binary_expr -> expr PLUS expr .)
    EXIT            reduce using rule 62 (binary_expr -> expr PLUS expr .)
    NOT             reduce using rule 62 (binary_expr -> expr PLUS expr .)
    RCURLYEBR       reduce using rule 62 (binary_expr -> expr PLUS expr .)
    END             reduce using rule 62 (binary_expr -> expr PLUS expr .)
    ELSE            reduce using rule 62 (binary_expr -> expr PLUS expr .)
    COMMA           reduce using rule 62 (binary_expr -> expr PLUS expr .)
    RSQUAREBR       reduce using rule 62 (binary_expr -> expr PLUS expr .)
    COLON           reduce using rule 62 (binary_expr -> expr PLUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 62 (binary_expr -> expr PLUS expr .)
    TO              reduce using rule 62 (binary_expr -> expr PLUS expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! PLUS            [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! MINUS           [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! TIMES           [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! LESS_THAN       [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! NOT_EQ          [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! AND             [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]
  ! OR              [ reduce using rule 62 (binary_expr -> expr PLUS expr .) ]


state 133

    (63) binary_expr -> expr MINUS expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 63 (binary_expr -> expr MINUS expr .)
    RPAREN          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    FN              reduce using rule 63 (binary_expr -> expr MINUS expr .)
    $end            reduce using rule 63 (binary_expr -> expr MINUS expr .)
    ID              reduce using rule 63 (binary_expr -> expr MINUS expr .)
    NUMBER          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    STRING          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    NULL            reduce using rule 63 (binary_expr -> expr MINUS expr .)
    LPAREN          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    IF              reduce using rule 63 (binary_expr -> expr MINUS expr .)
    WHILE           reduce using rule 63 (binary_expr -> expr MINUS expr .)
    FOR             reduce using rule 63 (binary_expr -> expr MINUS expr .)
    DO              reduce using rule 63 (binary_expr -> expr MINUS expr .)
    RETURN          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    BEGIN           reduce using rule 63 (binary_expr -> expr MINUS expr .)
    SCAN            reduce using rule 63 (binary_expr -> expr MINUS expr .)
    PRINT           reduce using rule 63 (binary_expr -> expr MINUS expr .)
    LENGTH          reduce using rule 63 (binary_expr -> expr MINUS expr .)
    EXIT            reduce using rule 63 (binary_expr -> expr MINUS expr .)
    NOT             reduce using rule 63 (binary_expr -> expr MINUS expr .)
    RCURLYEBR       reduce using rule 63 (binary_expr -> expr MINUS expr .)
    END             reduce using rule 63 (binary_expr -> expr MINUS expr .)
    ELSE            reduce using rule 63 (binary_expr -> expr MINUS expr .)
    COMMA           reduce using rule 63 (binary_expr -> expr MINUS expr .)
    RSQUAREBR       reduce using rule 63 (binary_expr -> expr MINUS expr .)
    COLON           reduce using rule 63 (binary_expr -> expr MINUS expr .)
    DOUBLE_RSQUAREBR reduce using rule 63 (binary_expr -> expr MINUS expr .)
    TO              reduce using rule 63 (binary_expr -> expr MINUS expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! QUESTION_MARK   [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! PLUS            [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! MINUS           [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! TIMES           [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! GREATER_THAN    [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! LESS_THAN       [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! NOT_EQ          [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! AND             [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]
  ! OR              [ reduce using rule 63 (binary_expr -> expr MINUS expr .) ]


state 134

    (64) binary_expr -> expr TIMES expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 64 (binary_expr -> expr TIMES expr .)
    RPAREN          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    FN              reduce using rule 64 (binary_expr -> expr TIMES expr .)
    $end            reduce using rule 64 (binary_expr -> expr TIMES expr .)
    ID              reduce using rule 64 (binary_expr -> expr TIMES expr .)
    NUMBER          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    STRING          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    NULL            reduce using rule 64 (binary_expr -> expr TIMES expr .)
    LPAREN          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    IF              reduce using rule 64 (binary_expr -> expr TIMES expr .)
    WHILE           reduce using rule 64 (binary_expr -> expr TIMES expr .)
    FOR             reduce using rule 64 (binary_expr -> expr TIMES expr .)
    DO              reduce using rule 64 (binary_expr -> expr TIMES expr .)
    RETURN          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    BEGIN           reduce using rule 64 (binary_expr -> expr TIMES expr .)
    SCAN            reduce using rule 64 (binary_expr -> expr TIMES expr .)
    PRINT           reduce using rule 64 (binary_expr -> expr TIMES expr .)
    LENGTH          reduce using rule 64 (binary_expr -> expr TIMES expr .)
    EXIT            reduce using rule 64 (binary_expr -> expr TIMES expr .)
    NOT             reduce using rule 64 (binary_expr -> expr TIMES expr .)
    RCURLYEBR       reduce using rule 64 (binary_expr -> expr TIMES expr .)
    END             reduce using rule 64 (binary_expr -> expr TIMES expr .)
    ELSE            reduce using rule 64 (binary_expr -> expr TIMES expr .)
    COMMA           reduce using rule 64 (binary_expr -> expr TIMES expr .)
    RSQUAREBR       reduce using rule 64 (binary_expr -> expr TIMES expr .)
    COLON           reduce using rule 64 (binary_expr -> expr TIMES expr .)
    DOUBLE_RSQUAREBR reduce using rule 64 (binary_expr -> expr TIMES expr .)
    TO              reduce using rule 64 (binary_expr -> expr TIMES expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! QUESTION_MARK   [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! PLUS            [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! MINUS           [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! TIMES           [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! DIVIDE          [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! GREATER_THAN    [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! LESS_THAN       [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! NOT_EQ          [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! AND             [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]
  ! OR              [ reduce using rule 64 (binary_expr -> expr TIMES expr .) ]


state 135

    (65) binary_expr -> expr DIVIDE expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    FN              reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    $end            reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    ID              reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    NUMBER          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    STRING          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    NULL            reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    LPAREN          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    IF              reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    WHILE           reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    FOR             reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    DO              reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    RETURN          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    BEGIN           reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    SCAN            reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    PRINT           reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    LENGTH          reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    EXIT            reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    NOT             reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    RCURLYEBR       reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    END             reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    ELSE            reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    RSQUAREBR       reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    COLON           reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    DOUBLE_RSQUAREBR reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    TO              reduce using rule 65 (binary_expr -> expr DIVIDE expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! QUESTION_MARK   [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! PLUS            [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! MINUS           [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! TIMES           [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! DIVIDE          [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! GREATER_THAN    [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! LESS_THAN       [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! NOT_EQ          [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! AND             [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]
  ! OR              [ reduce using rule 65 (binary_expr -> expr DIVIDE expr .) ]


state 136

    (66) binary_expr -> expr GREATER_THAN expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    RPAREN          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    FN              reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    $end            reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    ID              reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    NUMBER          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    STRING          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    NULL            reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    LPAREN          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    IF              reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    WHILE           reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    FOR             reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    DO              reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    RETURN          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    BEGIN           reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    SCAN            reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    PRINT           reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    LENGTH          reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    EXIT            reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    NOT             reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    RCURLYEBR       reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    END             reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    ELSE            reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    COMMA           reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    RSQUAREBR       reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    COLON           reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    DOUBLE_RSQUAREBR reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    TO              reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! QUESTION_MARK   [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! PLUS            [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! MINUS           [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! TIMES           [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! GREATER_THAN    [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! LESS_THAN       [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! NOT_EQ          [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! AND             [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]
  ! OR              [ reduce using rule 66 (binary_expr -> expr GREATER_THAN expr .) ]


state 137

    (67) binary_expr -> expr LESS_THAN expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    RPAREN          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    FN              reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    $end            reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    ID              reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    NUMBER          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    STRING          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    NULL            reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    LPAREN          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    IF              reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    WHILE           reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    FOR             reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    DO              reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    RETURN          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    BEGIN           reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    SCAN            reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    PRINT           reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    LENGTH          reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    EXIT            reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    NOT             reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    RCURLYEBR       reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    END             reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    ELSE            reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    COMMA           reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    RSQUAREBR       reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    COLON           reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    DOUBLE_RSQUAREBR reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    TO              reduce using rule 67 (binary_expr -> expr LESS_THAN expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! QUESTION_MARK   [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! PLUS            [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! MINUS           [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! TIMES           [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! DIVIDE          [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! GREATER_THAN    [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! LESS_THAN       [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! NOT_EQ          [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! AND             [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]
  ! OR              [ reduce using rule 67 (binary_expr -> expr LESS_THAN expr .) ]


state 138

    (68) binary_expr -> expr DOUBLE_EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    RPAREN          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    FN              reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    $end            reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    ID              reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    NUMBER          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    STRING          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    NULL            reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    LPAREN          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    IF              reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    WHILE           reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    FOR             reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    DO              reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    RETURN          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    BEGIN           reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    SCAN            reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    PRINT           reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    LENGTH          reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    EXIT            reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    NOT             reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    RCURLYEBR       reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    END             reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    ELSE            reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    COMMA           reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    RSQUAREBR       reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    COLON           reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    TO              reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! PLUS            [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! MINUS           [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! TIMES           [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! AND             [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]
  ! OR              [ reduce using rule 68 (binary_expr -> expr DOUBLE_EQ expr .) ]


state 139

    (69) binary_expr -> expr GREATER_THAN_EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RPAREN          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    FN              reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    $end            reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    ID              reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    NUMBER          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    STRING          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    NULL            reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    LPAREN          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    IF              reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    WHILE           reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    FOR             reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    DO              reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RETURN          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    BEGIN           reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    SCAN            reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    PRINT           reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    LENGTH          reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    EXIT            reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    NOT             reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RCURLYEBR       reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    END             reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    ELSE            reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    COMMA           reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    RSQUAREBR       reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    COLON           reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    TO              reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! PLUS            [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! MINUS           [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! TIMES           [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! AND             [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]
  ! OR              [ reduce using rule 69 (binary_expr -> expr GREATER_THAN_EQ expr .) ]


state 140

    (70) binary_expr -> expr LESS_THAN_EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    RPAREN          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    FN              reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    $end            reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    ID              reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    NUMBER          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    STRING          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    NULL            reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    LPAREN          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    IF              reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    WHILE           reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    FOR             reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    DO              reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    RETURN          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    BEGIN           reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    SCAN            reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    PRINT           reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    LENGTH          reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    EXIT            reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    NOT             reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    RCURLYEBR       reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    END             reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    ELSE            reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    COMMA           reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    RSQUAREBR       reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    COLON           reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    TO              reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! PLUS            [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! MINUS           [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! TIMES           [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! AND             [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]
  ! OR              [ reduce using rule 70 (binary_expr -> expr LESS_THAN_EQ expr .) ]


state 141

    (71) binary_expr -> expr NOT_EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    RPAREN          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    FN              reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    $end            reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    ID              reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    NUMBER          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    STRING          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    NULL            reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    LPAREN          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    IF              reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    WHILE           reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    FOR             reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    DO              reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    RETURN          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    BEGIN           reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    SCAN            reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    PRINT           reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    LENGTH          reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    EXIT            reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    NOT             reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    RCURLYEBR       reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    END             reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    ELSE            reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    COMMA           reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    RSQUAREBR       reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    COLON           reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    DOUBLE_RSQUAREBR reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    TO              reduce using rule 71 (binary_expr -> expr NOT_EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! QUESTION_MARK   [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! PLUS            [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! MINUS           [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! TIMES           [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! DIVIDE          [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! GREATER_THAN    [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! LESS_THAN       [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! NOT_EQ          [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! AND             [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]
  ! OR              [ reduce using rule 71 (binary_expr -> expr NOT_EQ expr .) ]


state 142

    (72) binary_expr -> expr AND expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 72 (binary_expr -> expr AND expr .)
    RPAREN          reduce using rule 72 (binary_expr -> expr AND expr .)
    FN              reduce using rule 72 (binary_expr -> expr AND expr .)
    $end            reduce using rule 72 (binary_expr -> expr AND expr .)
    ID              reduce using rule 72 (binary_expr -> expr AND expr .)
    NUMBER          reduce using rule 72 (binary_expr -> expr AND expr .)
    STRING          reduce using rule 72 (binary_expr -> expr AND expr .)
    NULL            reduce using rule 72 (binary_expr -> expr AND expr .)
    LPAREN          reduce using rule 72 (binary_expr -> expr AND expr .)
    IF              reduce using rule 72 (binary_expr -> expr AND expr .)
    WHILE           reduce using rule 72 (binary_expr -> expr AND expr .)
    FOR             reduce using rule 72 (binary_expr -> expr AND expr .)
    DO              reduce using rule 72 (binary_expr -> expr AND expr .)
    RETURN          reduce using rule 72 (binary_expr -> expr AND expr .)
    BEGIN           reduce using rule 72 (binary_expr -> expr AND expr .)
    SCAN            reduce using rule 72 (binary_expr -> expr AND expr .)
    PRINT           reduce using rule 72 (binary_expr -> expr AND expr .)
    LENGTH          reduce using rule 72 (binary_expr -> expr AND expr .)
    EXIT            reduce using rule 72 (binary_expr -> expr AND expr .)
    NOT             reduce using rule 72 (binary_expr -> expr AND expr .)
    RCURLYEBR       reduce using rule 72 (binary_expr -> expr AND expr .)
    END             reduce using rule 72 (binary_expr -> expr AND expr .)
    ELSE            reduce using rule 72 (binary_expr -> expr AND expr .)
    COMMA           reduce using rule 72 (binary_expr -> expr AND expr .)
    RSQUAREBR       reduce using rule 72 (binary_expr -> expr AND expr .)
    COLON           reduce using rule 72 (binary_expr -> expr AND expr .)
    DOUBLE_RSQUAREBR reduce using rule 72 (binary_expr -> expr AND expr .)
    TO              reduce using rule 72 (binary_expr -> expr AND expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! QUESTION_MARK   [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! PLUS            [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! GREATER_THAN    [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! LESS_THAN       [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! NOT_EQ          [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! AND             [ reduce using rule 72 (binary_expr -> expr AND expr .) ]
  ! OR              [ reduce using rule 72 (binary_expr -> expr AND expr .) ]


state 143

    (73) binary_expr -> expr OR expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 73 (binary_expr -> expr OR expr .)
    RPAREN          reduce using rule 73 (binary_expr -> expr OR expr .)
    FN              reduce using rule 73 (binary_expr -> expr OR expr .)
    $end            reduce using rule 73 (binary_expr -> expr OR expr .)
    ID              reduce using rule 73 (binary_expr -> expr OR expr .)
    NUMBER          reduce using rule 73 (binary_expr -> expr OR expr .)
    STRING          reduce using rule 73 (binary_expr -> expr OR expr .)
    NULL            reduce using rule 73 (binary_expr -> expr OR expr .)
    LPAREN          reduce using rule 73 (binary_expr -> expr OR expr .)
    IF              reduce using rule 73 (binary_expr -> expr OR expr .)
    WHILE           reduce using rule 73 (binary_expr -> expr OR expr .)
    FOR             reduce using rule 73 (binary_expr -> expr OR expr .)
    DO              reduce using rule 73 (binary_expr -> expr OR expr .)
    RETURN          reduce using rule 73 (binary_expr -> expr OR expr .)
    BEGIN           reduce using rule 73 (binary_expr -> expr OR expr .)
    SCAN            reduce using rule 73 (binary_expr -> expr OR expr .)
    PRINT           reduce using rule 73 (binary_expr -> expr OR expr .)
    LENGTH          reduce using rule 73 (binary_expr -> expr OR expr .)
    EXIT            reduce using rule 73 (binary_expr -> expr OR expr .)
    NOT             reduce using rule 73 (binary_expr -> expr OR expr .)
    RCURLYEBR       reduce using rule 73 (binary_expr -> expr OR expr .)
    END             reduce using rule 73 (binary_expr -> expr OR expr .)
    ELSE            reduce using rule 73 (binary_expr -> expr OR expr .)
    COMMA           reduce using rule 73 (binary_expr -> expr OR expr .)
    RSQUAREBR       reduce using rule 73 (binary_expr -> expr OR expr .)
    COLON           reduce using rule 73 (binary_expr -> expr OR expr .)
    DOUBLE_RSQUAREBR reduce using rule 73 (binary_expr -> expr OR expr .)
    TO              reduce using rule 73 (binary_expr -> expr OR expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! QUESTION_MARK   [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! PLUS            [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! GREATER_THAN    [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! LESS_THAN       [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! NOT_EQ          [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 73 (binary_expr -> expr OR expr .) ]
  ! OR              [ reduce using rule 73 (binary_expr -> expr OR expr .) ]


state 144

    (28) single_if -> IF DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR stmt
    (29) else_if -> IF DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR stmt ELSE stmt
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    DOUBLE_RSQUAREBR shift and go to state 162
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 145

    (86) else_if -> IF DOUBLE_LSQUAREBR error . DOUBLE_RSQUAREBR stmt ELSE stmt

    DOUBLE_RSQUAREBR shift and go to state 163


state 146

    (81) single_if -> IF LCURLYEBR error . RCURLYEBR stmt

    RCURLYEBR       shift and go to state 164


state 147

    (24) while_loop -> WHILE LPAREN expr . RPAREN stmt
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 165
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 148

    (82) while_loop -> WHILE LPAREN error . RPAREN stmt

    RPAREN          shift and go to state 166


state 149

    (25) for_loop -> FOR LPAREN ID . EQ expr TO expr RPAREN stmt
    (87) for_loop -> FOR LPAREN ID . EQ error TO expr RPAREN stmt
    (88) for_loop -> FOR LPAREN ID . EQ expr TO error RPAREN stmt
    (89) for_loop -> FOR LPAREN ID . EQ error TO error RPAREN stmt

    EQ              shift and go to state 167


state 150

    (26) do_while -> DO stmt WHILE . DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR

    DOUBLE_LSQUAREBR shift and go to state 168


state 151

    (27) block -> BEGIN body END .

    ID              reduce using rule 27 (block -> BEGIN body END .)
    NUMBER          reduce using rule 27 (block -> BEGIN body END .)
    STRING          reduce using rule 27 (block -> BEGIN body END .)
    NULL            reduce using rule 27 (block -> BEGIN body END .)
    LPAREN          reduce using rule 27 (block -> BEGIN body END .)
    IF              reduce using rule 27 (block -> BEGIN body END .)
    WHILE           reduce using rule 27 (block -> BEGIN body END .)
    FOR             reduce using rule 27 (block -> BEGIN body END .)
    DO              reduce using rule 27 (block -> BEGIN body END .)
    RETURN          reduce using rule 27 (block -> BEGIN body END .)
    BEGIN           reduce using rule 27 (block -> BEGIN body END .)
    SCAN            reduce using rule 27 (block -> BEGIN body END .)
    PRINT           reduce using rule 27 (block -> BEGIN body END .)
    LENGTH          reduce using rule 27 (block -> BEGIN body END .)
    EXIT            reduce using rule 27 (block -> BEGIN body END .)
    FN              reduce using rule 27 (block -> BEGIN body END .)
    LSQUAREBR       reduce using rule 27 (block -> BEGIN body END .)
    NOT             reduce using rule 27 (block -> BEGIN body END .)
    PLUS            reduce using rule 27 (block -> BEGIN body END .)
    MINUS           reduce using rule 27 (block -> BEGIN body END .)
    RCURLYEBR       reduce using rule 27 (block -> BEGIN body END .)
    END             reduce using rule 27 (block -> BEGIN body END .)
    ELSE            reduce using rule 27 (block -> BEGIN body END .)


state 152

    (77) builtin_methods -> SCAN LPAREN RPAREN .

    SEMI_COLON      reduce using rule 77 (builtin_methods -> SCAN LPAREN RPAREN .)


state 153

    (78) builtin_methods -> PRINT LPAREN clist . RPAREN

    RPAREN          shift and go to state 169


state 154

    (79) builtin_methods -> LENGTH LPAREN clist . RPAREN

    RPAREN          shift and go to state 170


state 155

    (80) builtin_methods -> EXIT LPAREN clist . RPAREN

    RPAREN          shift and go to state 171


state 156

    (59) expr_list -> LSQUAREBR clist RSQUAREBR .

    SEMI_COLON      reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LSQUAREBR       reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    QUESTION_MARK   reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    PLUS            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    MINUS           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    TIMES           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DIVIDE          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    GREATER_THAN    reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LESS_THAN       reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DOUBLE_EQ       reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    GREATER_THAN_EQ reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LESS_THAN_EQ    reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    NOT_EQ          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    AND             reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    OR              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RPAREN          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    FN              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    $end            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    ID              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    NUMBER          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    STRING          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    NULL            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LPAREN          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    IF              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    WHILE           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    FOR             reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DO              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RETURN          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    BEGIN           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    SCAN            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    PRINT           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    LENGTH          reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    EXIT            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    NOT             reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RCURLYEBR       reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    END             reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    ELSE            reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    COMMA           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    RSQUAREBR       reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    COLON           reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    DOUBLE_RSQUAREBR reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)
    TO              reduce using rule 59 (expr_list -> LSQUAREBR clist RSQUAREBR .)


state 157

    (44) clist -> expr COMMA . clist
    (42) clist -> . empty
    (43) clist -> . expr
    (44) clist -> . expr COMMA clist
    (5) empty -> .
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    RSQUAREBR       reduce using rule 5 (empty -> .)
    RPAREN          reduce using rule 5 (empty -> .)
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 121
    clist                          shift and go to state 172
    empty                          shift and go to state 120
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 158

    (31) defvar -> ID DBL_COLON type EQ . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 173
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 159

    (61) function_call -> ID LPAREN clist RPAREN .

    SEMI_COLON      reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    LSQUAREBR       reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    QUESTION_MARK   reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    PLUS            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    MINUS           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    TIMES           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    DIVIDE          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    GREATER_THAN    reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    LESS_THAN       reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    DOUBLE_EQ       reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    GREATER_THAN_EQ reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    LESS_THAN_EQ    reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    NOT_EQ          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    AND             reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    OR              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    RPAREN          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    FN              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    $end            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    ID              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    NUMBER          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    STRING          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    NULL            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    LPAREN          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    IF              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    WHILE           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    FOR             reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    DO              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    RETURN          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    BEGIN           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    SCAN            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    PRINT           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    LENGTH          reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    EXIT            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    NOT             reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    RCURLYEBR       reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    END             reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    ELSE            reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    COMMA           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    RSQUAREBR       reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    COLON           reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    DOUBLE_RSQUAREBR reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)
    TO              reduce using rule 61 (function_call -> ID LPAREN clist RPAREN .)


state 160

    (58) on_list -> expr LSQUAREBR expr RSQUAREBR .

    SEMI_COLON      reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LSQUAREBR       reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    QUESTION_MARK   reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    PLUS            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    MINUS           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    TIMES           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DIVIDE          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    GREATER_THAN    reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LESS_THAN       reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DOUBLE_EQ       reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    GREATER_THAN_EQ reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LESS_THAN_EQ    reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    NOT_EQ          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    AND             reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    OR              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RPAREN          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    FN              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    $end            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    ID              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    NUMBER          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    STRING          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    NULL            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LPAREN          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    IF              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    WHILE           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    FOR             reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DO              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RETURN          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    BEGIN           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    SCAN            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    PRINT           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    LENGTH          reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    EXIT            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    NOT             reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RCURLYEBR       reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    END             reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    ELSE            reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    COMMA           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    RSQUAREBR       reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    COLON           reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    DOUBLE_RSQUAREBR reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)
    TO              reduce using rule 58 (on_list -> expr LSQUAREBR expr RSQUAREBR .)


state 161

    (60) ternary_expr -> expr QUESTION_MARK expr COLON . expr
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 174
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 162

    (28) single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR . stmt
    (29) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR . stmt ELSE stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 175
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 163

    (86) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR . stmt ELSE stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 176
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 164

    (81) single_if -> IF LCURLYEBR error RCURLYEBR . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 177
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 165

    (24) while_loop -> WHILE LPAREN expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 178
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 166

    (82) while_loop -> WHILE LPAREN error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 179
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 167

    (25) for_loop -> FOR LPAREN ID EQ . expr TO expr RPAREN stmt
    (87) for_loop -> FOR LPAREN ID EQ . error TO expr RPAREN stmt
    (88) for_loop -> FOR LPAREN ID EQ . expr TO error RPAREN stmt
    (89) for_loop -> FOR LPAREN ID EQ . error TO error RPAREN stmt
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 181
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 180
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 168

    (26) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR . expr DOUBLE_RSQUAREBR
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 182
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 169

    (78) builtin_methods -> PRINT LPAREN clist RPAREN .

    SEMI_COLON      reduce using rule 78 (builtin_methods -> PRINT LPAREN clist RPAREN .)


state 170

    (79) builtin_methods -> LENGTH LPAREN clist RPAREN .

    SEMI_COLON      reduce using rule 79 (builtin_methods -> LENGTH LPAREN clist RPAREN .)


state 171

    (80) builtin_methods -> EXIT LPAREN clist RPAREN .

    SEMI_COLON      reduce using rule 80 (builtin_methods -> EXIT LPAREN clist RPAREN .)


state 172

    (44) clist -> expr COMMA clist .

    RSQUAREBR       reduce using rule 44 (clist -> expr COMMA clist .)
    RPAREN          reduce using rule 44 (clist -> expr COMMA clist .)


state 173

    (31) defvar -> ID DBL_COLON type EQ expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    SEMI_COLON      reduce using rule 31 (defvar -> ID DBL_COLON type EQ expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 174

    (60) ternary_expr -> expr QUESTION_MARK expr COLON expr .
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

  ! shift/reduce conflict for LSQUAREBR resolved as shift
  ! shift/reduce conflict for QUESTION_MARK resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER_THAN resolved as shift
  ! shift/reduce conflict for LESS_THAN resolved as shift
  ! shift/reduce conflict for DOUBLE_EQ resolved as shift
  ! shift/reduce conflict for GREATER_THAN_EQ resolved as shift
  ! shift/reduce conflict for LESS_THAN_EQ resolved as shift
  ! shift/reduce conflict for NOT_EQ resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMI_COLON      reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RPAREN          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    FN              reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    $end            reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    ID              reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    NUMBER          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    STRING          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    NULL            reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    LPAREN          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    IF              reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    WHILE           reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    FOR             reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    DO              reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RETURN          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    BEGIN           reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    SCAN            reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    PRINT           reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    LENGTH          reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    EXIT            reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    NOT             reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RCURLYEBR       reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    END             reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    ELSE            reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    COMMA           reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    RSQUAREBR       reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    COLON           reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    DOUBLE_RSQUAREBR reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    TO              reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .)
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102

  ! LSQUAREBR       [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! QUESTION_MARK   [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! PLUS            [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! MINUS           [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! TIMES           [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! DIVIDE          [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! GREATER_THAN    [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! LESS_THAN       [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! DOUBLE_EQ       [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! GREATER_THAN_EQ [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! LESS_THAN_EQ    [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! NOT_EQ          [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! AND             [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]
  ! OR              [ reduce using rule 60 (ternary_expr -> expr QUESTION_MARK expr COLON expr .) ]


state 175

    (28) single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .
    (29) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    ID              reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    NUMBER          reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    STRING          reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    NULL            reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    LPAREN          reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    IF              reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    WHILE           reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    FOR             reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    DO              reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    RETURN          reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    BEGIN           reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    SCAN            reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    PRINT           reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    LENGTH          reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    EXIT            reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    FN              reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    LSQUAREBR       reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    NOT             reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    PLUS            reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    MINUS           reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    RCURLYEBR       reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    END             reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .)
    ELSE            shift and go to state 183

  ! ELSE            [ reduce using rule 28 (single_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt .) ]


state 176

    (86) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt . ELSE stmt

    ELSE            shift and go to state 184


state 177

    (81) single_if -> IF LCURLYEBR error RCURLYEBR stmt .

    ID              reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    NUMBER          reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    STRING          reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    NULL            reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    LPAREN          reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    IF              reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    WHILE           reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    FOR             reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    DO              reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    RETURN          reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    BEGIN           reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    SCAN            reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    PRINT           reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    LENGTH          reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    EXIT            reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    FN              reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    LSQUAREBR       reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    NOT             reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    PLUS            reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    MINUS           reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    RCURLYEBR       reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    END             reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)
    ELSE            reduce using rule 81 (single_if -> IF LCURLYEBR error RCURLYEBR stmt .)


state 178

    (24) while_loop -> WHILE LPAREN expr RPAREN stmt .

    ID              reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NUMBER          reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    STRING          reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NULL            reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LPAREN          reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    IF              reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    WHILE           reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FOR             reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    DO              reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RETURN          reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    BEGIN           reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    SCAN            reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PRINT           reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LENGTH          reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    EXIT            reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    FN              reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    NOT             reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    PLUS            reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    MINUS           reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    END             reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)
    ELSE            reduce using rule 24 (while_loop -> WHILE LPAREN expr RPAREN stmt .)


state 179

    (82) while_loop -> WHILE LPAREN error RPAREN stmt .

    ID              reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    NUMBER          reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    STRING          reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    NULL            reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    LPAREN          reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    IF              reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    WHILE           reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    FOR             reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    DO              reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    RETURN          reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    BEGIN           reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    SCAN            reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    PRINT           reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    LENGTH          reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    EXIT            reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    FN              reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    LSQUAREBR       reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    NOT             reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    PLUS            reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    MINUS           reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    RCURLYEBR       reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    END             reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)
    ELSE            reduce using rule 82 (while_loop -> WHILE LPAREN error RPAREN stmt .)


state 180

    (25) for_loop -> FOR LPAREN ID EQ expr . TO expr RPAREN stmt
    (88) for_loop -> FOR LPAREN ID EQ expr . TO error RPAREN stmt
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    TO              shift and go to state 185
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 181

    (87) for_loop -> FOR LPAREN ID EQ error . TO expr RPAREN stmt
    (89) for_loop -> FOR LPAREN ID EQ error . TO error RPAREN stmt

    TO              shift and go to state 186


state 182

    (26) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr . DOUBLE_RSQUAREBR
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    DOUBLE_RSQUAREBR shift and go to state 187
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 183

    (29) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 188
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 184

    (86) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 189
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 185

    (25) for_loop -> FOR LPAREN ID EQ expr TO . expr RPAREN stmt
    (88) for_loop -> FOR LPAREN ID EQ expr TO . error RPAREN stmt
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 191
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 190
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 186

    (87) for_loop -> FOR LPAREN ID EQ error TO . expr RPAREN stmt
    (89) for_loop -> FOR LPAREN ID EQ error TO . error RPAREN stmt
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr
    (61) function_call -> . ID LPAREN clist RPAREN

    error           shift and go to state 192
    ID              shift and go to state 84
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 193
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61
    function_call                  shift and go to state 85

state 187

    (26) do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .

    ID              reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    NUMBER          reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    STRING          reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    NULL            reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    LPAREN          reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    IF              reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    WHILE           reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    FOR             reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    DO              reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    RETURN          reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    BEGIN           reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    SCAN            reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    PRINT           reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    LENGTH          reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    EXIT            reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    FN              reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    LSQUAREBR       reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    NOT             reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    PLUS            reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    MINUS           reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    RCURLYEBR       reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    END             reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)
    ELSE            reduce using rule 26 (do_while -> DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR .)


state 188

    (29) else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .

    ID              reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NUMBER          reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    STRING          reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NULL            reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LPAREN          reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    IF              reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    WHILE           reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FOR             reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    DO              reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RETURN          reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    BEGIN           reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    SCAN            reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PRINT           reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LENGTH          reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    EXIT            reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FN              reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LSQUAREBR       reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NOT             reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PLUS            reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    MINUS           reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RCURLYEBR       reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    END             reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)
    ELSE            reduce using rule 29 (else_if -> IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt .)


state 189

    (86) else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .

    ID              reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NUMBER          reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    STRING          reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NULL            reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LPAREN          reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    IF              reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    WHILE           reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FOR             reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    DO              reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RETURN          reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    BEGIN           reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    SCAN            reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PRINT           reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LENGTH          reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    EXIT            reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    FN              reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    LSQUAREBR       reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    NOT             reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    PLUS            reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    MINUS           reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    RCURLYEBR       reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    END             reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)
    ELSE            reduce using rule 86 (else_if -> IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt .)


state 190

    (25) for_loop -> FOR LPAREN ID EQ expr TO expr . RPAREN stmt
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 194
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 191

    (88) for_loop -> FOR LPAREN ID EQ expr TO error . RPAREN stmt

    RPAREN          shift and go to state 195


state 192

    (89) for_loop -> FOR LPAREN ID EQ error TO error . RPAREN stmt

    RPAREN          shift and go to state 196


state 193

    (87) for_loop -> FOR LPAREN ID EQ error TO expr . RPAREN stmt
    (58) on_list -> expr . LSQUAREBR expr RSQUAREBR
    (60) ternary_expr -> expr . QUESTION_MARK expr COLON expr
    (62) binary_expr -> expr . PLUS expr
    (63) binary_expr -> expr . MINUS expr
    (64) binary_expr -> expr . TIMES expr
    (65) binary_expr -> expr . DIVIDE expr
    (66) binary_expr -> expr . GREATER_THAN expr
    (67) binary_expr -> expr . LESS_THAN expr
    (68) binary_expr -> expr . DOUBLE_EQ expr
    (69) binary_expr -> expr . GREATER_THAN_EQ expr
    (70) binary_expr -> expr . LESS_THAN_EQ expr
    (71) binary_expr -> expr . NOT_EQ expr
    (72) binary_expr -> expr . AND expr
    (73) binary_expr -> expr . OR expr

    RPAREN          shift and go to state 197
    LSQUAREBR       shift and go to state 89
    QUESTION_MARK   shift and go to state 90
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    TIMES           shift and go to state 93
    DIVIDE          shift and go to state 94
    GREATER_THAN    shift and go to state 95
    LESS_THAN       shift and go to state 96
    DOUBLE_EQ       shift and go to state 97
    GREATER_THAN_EQ shift and go to state 98
    LESS_THAN_EQ    shift and go to state 99
    NOT_EQ          shift and go to state 100
    AND             shift and go to state 101
    OR              shift and go to state 102


state 194

    (25) for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 198
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 195

    (88) for_loop -> FOR LPAREN ID EQ expr TO error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 199
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 196

    (89) for_loop -> FOR LPAREN ID EQ error TO error RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    stmt                           shift and go to state 200
    expr                           shift and go to state 42
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 197

    (87) for_loop -> FOR LPAREN ID EQ error TO expr RPAREN . stmt
    (6) stmt -> . expr SEMI_COLON
    (7) stmt -> . defvar SEMI_COLON
    (8) stmt -> . func SEMI_COLON
    (9) stmt -> . single_if
    (10) stmt -> . else_if
    (11) stmt -> . while_loop
    (12) stmt -> . for_loop
    (13) stmt -> . do_while
    (14) stmt -> . return_is SEMI_COLON
    (15) stmt -> . block
    (16) stmt -> . builtin_methods SEMI_COLON
    (17) stmt -> . function_call SEMI_COLON
    (18) stmt -> . func1
    (19) stmt -> . func2
    (45) expr -> . on_list
    (46) expr -> . expr_list
    (47) expr -> . ternary_expr
    (48) expr -> . binary_expr
    (49) expr -> . single_expr
    (50) expr -> . ID
    (51) expr -> . assignment
    (52) expr -> . function_call
    (53) expr -> . NUMBER
    (54) expr -> . STRING
    (55) expr -> . NULL
    (56) expr -> . LPAREN expr RPAREN
    (30) defvar -> . ID DBL_COLON type
    (31) defvar -> . ID DBL_COLON type EQ expr
    (3) func -> . func1
    (4) func -> . func2
    (28) single_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt
    (81) single_if -> . IF LCURLYEBR error RCURLYEBR stmt
    (29) else_if -> . IF DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR stmt ELSE stmt
    (86) else_if -> . IF DOUBLE_LSQUAREBR error DOUBLE_RSQUAREBR stmt ELSE stmt
    (24) while_loop -> . WHILE LPAREN expr RPAREN stmt
    (82) while_loop -> . WHILE LPAREN error RPAREN stmt
    (25) for_loop -> . FOR LPAREN ID EQ expr TO expr RPAREN stmt
    (87) for_loop -> . FOR LPAREN ID EQ error TO expr RPAREN stmt
    (88) for_loop -> . FOR LPAREN ID EQ expr TO error RPAREN stmt
    (89) for_loop -> . FOR LPAREN ID EQ error TO error RPAREN stmt
    (26) do_while -> . DO stmt WHILE DOUBLE_LSQUAREBR expr DOUBLE_RSQUAREBR
    (22) return_is -> . RETURN expr
    (23) return_is -> . RETURN
    (27) block -> . BEGIN body END
    (77) builtin_methods -> . SCAN LPAREN RPAREN
    (78) builtin_methods -> . PRINT LPAREN clist RPAREN
    (79) builtin_methods -> . LENGTH LPAREN clist RPAREN
    (80) builtin_methods -> . EXIT LPAREN clist RPAREN
    (61) function_call -> . ID LPAREN clist RPAREN
    (37) func1 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN LCURLYEBR body RCURLYEBR
    (38) func2 -> . FN ID LPAREN flist RPAREN LESS_THAN type GREATER_THAN EQ GREATER_THAN return_is
    (58) on_list -> . expr LSQUAREBR expr RSQUAREBR
    (59) expr_list -> . LSQUAREBR clist RSQUAREBR
    (60) ternary_expr -> . expr QUESTION_MARK expr COLON expr
    (62) binary_expr -> . expr PLUS expr
    (63) binary_expr -> . expr MINUS expr
    (64) binary_expr -> . expr TIMES expr
    (65) binary_expr -> . expr DIVIDE expr
    (66) binary_expr -> . expr GREATER_THAN expr
    (67) binary_expr -> . expr LESS_THAN expr
    (68) binary_expr -> . expr DOUBLE_EQ expr
    (69) binary_expr -> . expr GREATER_THAN_EQ expr
    (70) binary_expr -> . expr LESS_THAN_EQ expr
    (71) binary_expr -> . expr NOT_EQ expr
    (72) binary_expr -> . expr AND expr
    (73) binary_expr -> . expr OR expr
    (74) single_expr -> . NOT expr
    (75) single_expr -> . PLUS expr
    (76) single_expr -> . MINUS expr
    (57) assignment -> . ID EQ expr

    ID              shift and go to state 37
    NUMBER          shift and go to state 62
    STRING          shift and go to state 63
    NULL            shift and go to state 64
    LPAREN          shift and go to state 38
    IF              shift and go to state 65
    WHILE           shift and go to state 66
    FOR             shift and go to state 67
    DO              shift and go to state 68
    RETURN          shift and go to state 69
    BEGIN           shift and go to state 70
    SCAN            shift and go to state 71
    PRINT           shift and go to state 72
    LENGTH          shift and go to state 73
    EXIT            shift and go to state 74
    FN              shift and go to state 6
    LSQUAREBR       shift and go to state 75
    NOT             shift and go to state 78
    PLUS            shift and go to state 76
    MINUS           shift and go to state 77

    expr                           shift and go to state 42
    stmt                           shift and go to state 201
    defvar                         shift and go to state 43
    func                           shift and go to state 44
    single_if                      shift and go to state 45
    else_if                        shift and go to state 46
    while_loop                     shift and go to state 47
    for_loop                       shift and go to state 48
    do_while                       shift and go to state 49
    return_is                      shift and go to state 50
    block                          shift and go to state 51
    builtin_methods                shift and go to state 52
    function_call                  shift and go to state 53
    func1                          shift and go to state 54
    func2                          shift and go to state 55
    on_list                        shift and go to state 56
    expr_list                      shift and go to state 57
    ternary_expr                   shift and go to state 58
    binary_expr                    shift and go to state 59
    single_expr                    shift and go to state 60
    assignment                     shift and go to state 61

state 198

    (25) for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .

    ID              reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    NUMBER          reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    STRING          reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    NULL            reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    LPAREN          reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    IF              reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    WHILE           reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    FOR             reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    DO              reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    RETURN          reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    BEGIN           reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    SCAN            reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    PRINT           reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    LENGTH          reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    EXIT            reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    FN              reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    NOT             reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    PLUS            reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    MINUS           reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    END             reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)
    ELSE            reduce using rule 25 (for_loop -> FOR LPAREN ID EQ expr TO expr RPAREN stmt .)


state 199

    (88) for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .

    ID              reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    NUMBER          reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    STRING          reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    NULL            reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    LPAREN          reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    IF              reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    WHILE           reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    FOR             reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    DO              reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    RETURN          reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    BEGIN           reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    SCAN            reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    PRINT           reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    LENGTH          reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    EXIT            reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    FN              reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    LSQUAREBR       reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    NOT             reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    PLUS            reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    MINUS           reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    RCURLYEBR       reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    END             reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)
    ELSE            reduce using rule 88 (for_loop -> FOR LPAREN ID EQ expr TO error RPAREN stmt .)


state 200

    (89) for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .

    ID              reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    NUMBER          reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    STRING          reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    NULL            reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    LPAREN          reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    IF              reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    WHILE           reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    FOR             reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    DO              reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    RETURN          reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    BEGIN           reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    SCAN            reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    PRINT           reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    LENGTH          reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    EXIT            reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    FN              reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    LSQUAREBR       reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    NOT             reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    PLUS            reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    MINUS           reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    RCURLYEBR       reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    END             reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)
    ELSE            reduce using rule 89 (for_loop -> FOR LPAREN ID EQ error TO error RPAREN stmt .)


state 201

    (87) for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .

    ID              reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    NUMBER          reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    STRING          reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    NULL            reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    LPAREN          reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    IF              reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    WHILE           reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    FOR             reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    DO              reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    RETURN          reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    BEGIN           reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    SCAN            reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    PRINT           reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    LENGTH          reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    EXIT            reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    FN              reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    LSQUAREBR       reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    NOT             reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    PLUS            reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    MINUS           reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    RCURLYEBR       reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    END             reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)
    ELSE            reduce using rule 87 (for_loop -> FOR LPAREN ID EQ error TO expr RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for SEMI_COLON in state 53 resolved as shift
WARNING: shift/reduce conflict for ID in state 69 resolved as shift
WARNING: shift/reduce conflict for NUMBER in state 69 resolved as shift
WARNING: shift/reduce conflict for STRING in state 69 resolved as shift
WARNING: shift/reduce conflict for NULL in state 69 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 69 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 69 resolved as shift
WARNING: shift/reduce conflict for NOT in state 69 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 69 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 69 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 84 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 113 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 113 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 113 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 122 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 122 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 122 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 122 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 122 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 122 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 122 resolved as shift
WARNING: shift/reduce conflict for AND in state 122 resolved as shift
WARNING: shift/reduce conflict for OR in state 122 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 123 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 123 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 123 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 123 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 123 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 123 resolved as shift
WARNING: shift/reduce conflict for OR in state 123 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 124 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 124 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 124 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 124 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 124 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 124 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 124 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 124 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 127 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 127 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 127 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 127 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 127 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 132 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 132 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 132 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 132 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 132 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 132 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 132 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 132 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 132 resolved as shift
WARNING: shift/reduce conflict for AND in state 132 resolved as shift
WARNING: shift/reduce conflict for OR in state 132 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 133 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 133 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 133 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 133 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 133 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 134 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 134 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 134 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 134 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 134 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for AND in state 134 resolved as shift
WARNING: shift/reduce conflict for OR in state 134 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 135 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 135 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 135 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 135 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 135 resolved as shift
WARNING: shift/reduce conflict for AND in state 135 resolved as shift
WARNING: shift/reduce conflict for OR in state 135 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 136 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 136 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 136 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 136 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 136 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 136 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 136 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 136 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 136 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 136 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 136 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 136 resolved as shift
WARNING: shift/reduce conflict for AND in state 136 resolved as shift
WARNING: shift/reduce conflict for OR in state 136 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 137 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 137 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 137 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 137 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 137 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 137 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 137 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 137 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 137 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 137 resolved as shift
WARNING: shift/reduce conflict for AND in state 137 resolved as shift
WARNING: shift/reduce conflict for OR in state 137 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 138 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 138 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 138 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 138 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 138 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 138 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 138 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 138 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 138 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 138 resolved as shift
WARNING: shift/reduce conflict for AND in state 138 resolved as shift
WARNING: shift/reduce conflict for OR in state 138 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 139 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 139 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 139 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 139 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 139 resolved as shift
WARNING: shift/reduce conflict for AND in state 139 resolved as shift
WARNING: shift/reduce conflict for OR in state 139 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 140 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 140 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 140 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 140 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 140 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 140 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 140 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 140 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 140 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 140 resolved as shift
WARNING: shift/reduce conflict for AND in state 140 resolved as shift
WARNING: shift/reduce conflict for OR in state 140 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 141 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 141 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 141 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 141 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 141 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 141 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 141 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 141 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 141 resolved as shift
WARNING: shift/reduce conflict for AND in state 141 resolved as shift
WARNING: shift/reduce conflict for OR in state 141 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 142 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 142 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 143 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 143 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 143 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for LSQUAREBR in state 174 resolved as shift
WARNING: shift/reduce conflict for QUESTION_MARK in state 174 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 174 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 174 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 174 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN in state 174 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN in state 174 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_EQ in state 174 resolved as shift
WARNING: shift/reduce conflict for GREATER_THAN_EQ in state 174 resolved as shift
WARNING: shift/reduce conflict for LESS_THAN_EQ in state 174 resolved as shift
WARNING: shift/reduce conflict for NOT_EQ in state 174 resolved as shift
WARNING: shift/reduce conflict for AND in state 174 resolved as shift
WARNING: shift/reduce conflict for OR in state 174 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 175 resolved as shift
